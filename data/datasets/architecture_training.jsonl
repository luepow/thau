{"instruction": "Explica el patrón de diseño Repository", "input": "", "output": "El patrón Repository actúa como una capa de abstracción entre la lógica de negocio y la capa de acceso a datos. Encapsula la lógica necesaria para acceder a las fuentes de datos, proporcionando una interfaz de colección para trabajar con objetos de dominio. Beneficios: desacoplamiento, testabilidad, centralización de la lógica de acceso a datos. Ejemplo: `class UserRepository { findById(id), save(user), delete(user) }`"}
{"instruction": "¿Qué es Clean Architecture?", "input": "", "output": "Clean Architecture es un patrón arquitectónico propuesto por Robert C. Martin que organiza el código en capas concéntricas: Entities (núcleo), Use Cases, Interface Adapters, Frameworks & Drivers. La regla de dependencia establece que las dependencias solo apuntan hacia adentro. Beneficios: independencia de frameworks, testabilidad, independencia de UI y base de datos."}
{"instruction": "Explica el principio SOLID", "input": "", "output": "SOLID es un acrónimo de 5 principios: S-Single Responsibility (una clase = una responsabilidad), O-Open/Closed (abierto a extensión, cerrado a modificación), L-Liskov Substitution (las subclases deben ser sustituibles por sus clases base), I-Interface Segregation (interfaces pequeñas y específicas), D-Dependency Inversion (depender de abstracciones, no de concreciones)."}
{"instruction": "¿Qué es el patrón MVC?", "input": "", "output": "Model-View-Controller separa la aplicación en 3 componentes: Model (datos y lógica de negocio), View (presentación e interfaz de usuario), Controller (maneja la entrada del usuario y actualiza el modelo). Flujo: Usuario -> Controller -> Model -> View. Beneficios: separación de responsabilidades, reutilización, mantenibilidad."}
{"instruction": "Explica el patrón Factory", "input": "", "output": "Factory es un patrón creacional que proporciona una interfaz para crear objetos sin especificar sus clases concretas. Ejemplo: `class UserFactory { static create(type) { if(type === 'admin') return new AdminUser(); return new RegularUser(); }}`. Beneficios: encapsulación de la creación, flexibilidad, reducción de acoplamiento."}
{"instruction": "¿Qué es Dependency Injection?", "input": "", "output": "Dependency Injection es un patrón donde las dependencias de una clase se inyectan desde el exterior en lugar de ser creadas internamente. Tipos: constructor injection, setter injection, interface injection. Ejemplo: `class UserService { constructor(userRepository) { this.repo = userRepository; }}`. Beneficios: desacoplamiento, testabilidad, flexibilidad."}
{"instruction": "Explica el patrón Observer", "input": "", "output": "Observer define una dependencia uno-a-muchos donde cuando un objeto cambia su estado, todos sus dependientes son notificados automáticamente. Componentes: Subject (observable), Observer (observador), ConcreteSubject, ConcreteObserver. Ejemplo: EventEmitter en Node.js, RxJS Observables. Beneficios: bajo acoplamiento, comunicación dinámica."}
{"instruction": "¿Qué es el patrón Singleton?", "input": "", "output": "Singleton asegura que una clase tenga solo una instancia y proporciona un punto de acceso global. Implementación: `class Database { static instance; static getInstance() { if(!this.instance) this.instance = new Database(); return this.instance; }}`. Úsalo con precaución: puede dificultar testing y crear acoplamiento global."}
{"instruction": "Explica el patrón Strategy", "input": "", "output": "Strategy define una familia de algoritmos, encapsula cada uno y los hace intercambiables. El algoritmo varía independientemente de los clientes que lo usan. Ejemplo: diferentes estrategias de ordenamiento (QuickSort, MergeSort, BubbleSort) implementando la misma interfaz SortStrategy. Beneficios: flexibilidad, eliminación de condicionales complejos."}
{"instruction": "¿Qué es CQRS?", "input": "", "output": "Command Query Responsibility Segregation separa las operaciones de lectura (queries) de las de escritura (commands). Los modelos de lectura y escritura pueden ser diferentes y optimizados para su propósito. Beneficios: escalabilidad independiente, optimización específica, claridad. Ideal para sistemas event-sourced."}
{"instruction": "Explica microservicios vs monolito", "input": "", "output": "Monolito: aplicación única autocontenida, deployment unificado, base de datos compartida. Microservicios: servicios independientes, deployment autónomo, base de datos por servicio. Monolito: simple al inicio, microservicios: escalable, tolerante a fallos, pero más complejo. Elige monolito para MVPs, microservicios cuando necesites escalar equipos/componentes independientemente."}
{"instruction": "¿Qué es Event-Driven Architecture?", "input": "", "output": "Arquitectura basada en eventos donde los componentes se comunican mediante eventos asíncronos. Componentes: Event Producers, Event Consumers, Event Broker (Kafka, RabbitMQ). Patrones: Event Notification, Event Sourcing, CQRS. Beneficios: desacoplamiento, escalabilidad, resiliencia. Desafíos: consistencia eventual, debugging complejo."}
{"instruction": "Explica el patrón API Gateway", "input": "", "output": "API Gateway es un servidor que actúa como punto de entrada único para un conjunto de microservicios. Responsabilidades: routing, composición, autenticación, rate limiting, caching, transformación de protocolos. Ejemplos: Kong, AWS API Gateway, nginx. Beneficios: simplificación del cliente, seguridad centralizada, monitoreo."}
{"instruction": "¿Qué es DDD (Domain-Driven Design)?", "input": "", "output": "DDD es un enfoque de diseño centrado en el dominio del negocio. Conceptos clave: Entities (identidad única), Value Objects (inmutables sin identidad), Aggregates (cluster de objetos), Repositories, Domain Events, Bounded Contexts (límites del modelo). Lenguaje ubicuo compartido entre devs y expertos del dominio."}
{"instruction": "Explica REST vs GraphQL", "input": "", "output": "REST: múltiples endpoints, over/under-fetching, versionado en URL, cacheo nativo HTTP. GraphQL: endpoint único, consulta exacta de datos, esquema tipado, subscripciones en tiempo real. REST: simple, maduro, cacheo fácil. GraphQL: flexible, eficiente, complejo. Elige REST para APIs CRUD simples, GraphQL para apps con necesidades de datos complejas."}
{"instruction": "¿Qué es el patrón Circuit Breaker?", "input": "", "output": "Circuit Breaker previene que una aplicación intente ejecutar operaciones que probablemente fallen. Estados: Closed (normal), Open (fallos detectados, rechaza requests), Half-Open (prueba recuperación). Ejemplo: Hystrix, Resilience4j. Útil en microservicios para prevenir cascada de fallos. Mejora resiliencia y experiencia de usuario."}
{"instruction": "Explica el patrón Saga", "input": "", "output": "Saga es un patrón para manejar transacciones distribuidas en microservicios mediante una secuencia de transacciones locales. Tipos: Choreography (eventos), Orchestration (coordinador central). Cada paso tiene una compensación para rollback. Ejemplo: Order Saga (crear orden -> reservar inventario -> procesar pago -> confirmar envío). Garantiza consistencia eventual."}
{"instruction": "¿Qué es el patrón BFF?", "input": "", "output": "Backend For Frontend crea un backend específico por cada tipo de cliente (web, móvil, etc). Cada BFF adapta la API a las necesidades específicas de su frontend. Beneficios: optimización por cliente, evolución independiente, reducción de lógica en frontend. Desafíos: duplicación de código, más complejidad operacional."}
{"instruction": "Explica el principio DRY", "input": "", "output": "Don't Repeat Yourself: cada pieza de conocimiento debe tener una representación única, autoritativa y sin ambigüedad en el sistema. No se trata solo de duplicación de código, sino de duplicación de conocimiento. Soluciones: abstracción, funciones reutilizables, herencia, composición. Balance: evita abstracciones prematuras."}
{"instruction": "¿Qué es arquitectura hexagonal?", "input": "", "output": "También llamada Ports & Adapters, separa la lógica core de la aplicación de servicios externos. Core: lógica de negocio. Ports: interfaces (APIs). Adapters: implementaciones concretas (DB, HTTP, etc). El core no conoce detalles de infraestructura. Beneficios: testabilidad, independencia de frameworks, intercambiabilidad de componentes."}
{"instruction": "Explica el patrón Adapter", "input": "", "output": "Adapter convierte la interfaz de una clase en otra que el cliente espera. Permite que clases con interfaces incompatibles trabajen juntas. Ejemplo: `class PayPalAdapter implements PaymentGateway { constructor(paypal) {} processPayment() { this.paypal.makePayment() }}`. Útil para integrar librerías de terceros o código legacy."}
{"instruction": "¿Qué es Twelve-Factor App?", "input": "", "output": "Metodología para construir SaaS: 1-Codebase único, 2-Dependencias declaradas, 3-Config en env vars, 4-Backing services como recursos, 5-Build/release/run separados, 6-Procesos stateless, 7-Port binding, 8-Concurrencia vía procesos, 9-Disposability rápida, 10-Dev/prod parity, 11-Logs como streams, 12-Admin tasks como one-off processes."}
{"instruction": "Explica el patrón Decorator", "input": "", "output": "Decorator añade responsabilidades adicionales a un objeto dinámicamente. Proporciona una alternativa flexible a la herencia para extender funcionalidad. Ejemplo: `class LoggingDecorator { constructor(service) {} execute() { log('start'); service.execute(); log('end') }}`. Beneficios: extensión sin modificación, composición dinámica."}
{"instruction": "¿Qué es el patrón Template Method?", "input": "", "output": "Template Method define el esqueleto de un algoritmo en una clase base, delegando algunos pasos a subclases. Las subclases redefinen ciertos pasos sin cambiar la estructura. Ejemplo: `abstract class DataParser { parse() { open(); extract(); transform(); close() } abstract extract(); }`. Promueve reutilización de código."}
{"instruction": "Explica el patrón Builder", "input": "", "output": "Builder separa la construcción de un objeto complejo de su representación. Permite crear diferentes representaciones usando el mismo proceso. Ejemplo: `class QueryBuilder { select(fields) {...} where(condition) {...} build() {...}}`. Beneficios: código legible, construcción paso a paso, inmutabilidad. Útil para objetos con muchos parámetros opcionales."}
{"instruction": "¿Qué es el patrón Proxy?", "input": "", "output": "Proxy proporciona un sustituto o placeholder para controlar el acceso a otro objeto. Tipos: Remote (objeto en diferente espacio de direcciones), Virtual (lazy loading), Protection (control de acceso). Ejemplo: cache proxy, authentication proxy. Beneficios: control adicional sin modificar el objeto original."}
{"instruction": "Explica el patrón Facade", "input": "", "output": "Facade proporciona una interfaz simplificada a un subsistema complejo. Oculta la complejidad del sistema y proporciona una interfaz más fácil de usar. Ejemplo: `class OrderFacade { placeOrder() { inventory.check(); payment.process(); shipping.schedule(); notification.send() }}`. Beneficios: simplificación, desacoplamiento de subsistemas."}
{"instruction": "¿Qué es event sourcing?", "input": "", "output": "Event Sourcing almacena el estado como secuencia de eventos en lugar de snapshots. Cada cambio es un evento inmutable. El estado actual se reconstruye reproduciendo eventos. Beneficios: auditoría completa, time travel, eventos como fuente de verdad. Desafíos: complejidad, snapshots para performance, migraciones de eventos."}
{"instruction": "Explica el patrón Mediator", "input": "", "output": "Mediator define un objeto que encapsula cómo un conjunto de objetos interactúan. Promueve acoplamiento débil evitando referencias explícitas entre objetos. Ejemplo: chatroom mediator coordina mensajes entre usuarios. Beneficios: reduce acoplamiento, centraliza lógica de interacción. Riesgo: el mediador puede volverse muy complejo."}
{"instruction": "¿Qué es CAP theorem?", "input": "", "output": "CAP: un sistema distribuido no puede garantizar simultáneamente Consistency (todos ven los mismos datos), Availability (sistema siempre responde), Partition tolerance (funciona pese a fallos de red). Debes elegir 2 de 3. CP: sistemas bancarios. AP: redes sociales. En práctica, la partición es inevitable, así que elige entre CA y AP según caso de uso."}
{"instruction": "Explica ACID vs BASE", "input": "", "output": "ACID (bases relacionales): Atomicity (todo o nada), Consistency (estado válido), Isolation (transacciones independientes), Durability (persistencia). BASE (NoSQL): Basically Available (disponibilidad), Soft state (estado puede cambiar), Eventually consistent (consistencia eventual). ACID: transacciones críticas. BASE: sistemas distribuidos de alta escala."}
{"instruction": "¿Qué es sharding de base de datos?", "input": "", "output": "Sharding divide datos horizontalmente en múltiples bases de datos (shards). Cada shard contiene un subset de datos. Estrategias: hash-based (por ID), range-based (por rango), geographic (por ubicación). Beneficios: escalabilidad horizontal, mejor performance. Desafíos: complejidad, joins cross-shard, rebalanceo."}
{"instruction": "Explica OAuth 2.0", "input": "", "output": "OAuth 2.0 es un framework de autorización que permite a apps obtener acceso limitado a recursos. Roles: Resource Owner, Client, Authorization Server, Resource Server. Flujos: Authorization Code (web apps), Implicit (deprecated), Client Credentials (service-to-service), Password (legacy). Usa PKCE para apps públicas. Tokens: access token (corta vida), refresh token."}
{"instruction": "¿Qué es JWT?", "input": "", "output": "JSON Web Token es un estándar para tokens de acceso. Estructura: Header.Payload.Signature. Header: algoritmo y tipo. Payload: claims (sub, exp, iat, custom). Signature: verificación. Stateless, no requiere base de datos. Desventajas: no revocable fácilmente, tamaño mayor que session ID. Úsalo para APIs stateless, combínalo con refresh tokens."}
{"instruction": "Explica contenedores vs VMs", "input": "", "output": "VMs: virtualización a nivel de hardware, OS completo, pesadas, aislamiento fuerte. Contenedores: virtualización a nivel de OS, comparten kernel, ligeros, arranque rápido. Docker empaqueta app + dependencias. VMs: aislamiento crítico, múltiples OS. Contenedores: microservicios, CI/CD, desarrollo. Kubernetes orquesta contenedores a escala."}
{"instruction": "¿Qué es CI/CD?", "input": "", "output": "Continuous Integration: merge frecuente de código con builds y tests automáticos. Continuous Delivery: código siempre listo para despliegue. Continuous Deployment: deploy automático a producción. Pipeline típico: commit -> build -> test -> deploy. Herramientas: Jenkins, GitHub Actions, GitLab CI. Beneficios: feedback rápido, menos bugs, releases frecuentes."}
{"instruction": "Explica el patrón Repository + Unit of Work", "input": "", "output": "Repository abstrae el acceso a datos. Unit of Work mantiene lista de objetos afectados por transacción y coordina cambios. Juntos proporcionan: transacciones consistentes, desacoplamiento de persistencia, testabilidad. Ejemplo: `unitOfWork.begin(); userRepo.save(user); orderRepo.save(order); unitOfWork.commit();`. Rollback automático en errores."}
{"instruction": "¿Qué es idempotencia?", "input": "", "output": "Una operación es idempotente si ejecutarla múltiples veces produce el mismo resultado que ejecutarla una vez. Métodos HTTP idempotentes: GET, PUT, DELETE. POST no es idempotente. Importante en: retry logic, sistemas distribuidos, procesamiento de mensajes. Implementación: idempotency keys, check-then-act patterns."}
{"instruction": "Explica rate limiting", "input": "", "output": "Rate Limiting restringe el número de requests en un período de tiempo. Algoritmos: Token Bucket (flexible), Leaky Bucket (suaviza picos), Fixed Window (simple, edge cases), Sliding Window (preciso). Niveles: por usuario, por IP, por API key. Implementación: Redis, middleware. Beneficios: previene abuso, protege recursos, garantiza QoS."}
{"instruction": "¿Qué es caching y cuándo usarlo?", "input": "", "output": "Caching almacena datos frecuentemente accedidos en memoria rápida. Tipos: in-memory (Redis, Memcached), CDN, browser, database query cache. Estrategias: cache-aside, write-through, write-behind. Invalidación: TTL, event-based. Úsalo para: datos caros de computar, lectura frecuente, tolerancia a staleness. Considera: consistencia, memory limits."}
{"instruction": "Explica blue-green deployment", "input": "", "output": "Blue-Green Deployment mantiene dos entornos idénticos: Blue (producción actual) y Green (nueva versión). Deploy a Green, prueba, switch tráfico. Rollback instantáneo cambiando de vuelta. Beneficios: zero downtime, rollback fácil, testing en producción. Desafíos: doble infraestructura, migraciones de DB, costos. Alternativa: canary deployments."}
{"instruction": "¿Qué es un load balancer?", "input": "", "output": "Load Balancer distribuye tráfico entre múltiples servidores. Algoritmos: Round Robin, Least Connections, IP Hash, Weighted. Tipos: Layer 4 (TCP/UDP), Layer 7 (HTTP). Features: health checks, SSL termination, session persistence. Ejemplos: nginx, HAProxy, AWS ELB. Beneficios: escalabilidad, alta disponibilidad, mejor performance."}
{"instruction": "Explica el patrón Saga con compensación", "input": "", "output": "Saga coordina transacciones distribuidas mediante transacciones locales secuenciales. Cada paso tiene una transacción compensatoria para rollback. Ejemplo: CreateOrder (CancelOrder), ReserveInventory (ReleaseInventory), ChargePayment (RefundPayment). Si falla en paso 3, ejecuta compensaciones en orden inverso. Garantiza consistencia eventual sin locks distribuidos."}
{"instruction": "¿Qué es database denormalization?", "input": "", "output": "Denormalization introduce redundancia intencional para mejorar performance de lectura. Opuesto a normalización (eliminar redundancia). Técnicas: duplicar datos, precalcular agregaciones, mantener snapshots. Trade-offs: lecturas rápidas vs escrituras complejas, espacio vs tiempo. Úsalo en: sistemas read-heavy, data warehouses, caching layers. Mantén sincronización consistente."}
{"instruction": "Explica el patrón Strangler Fig", "input": "", "output": "Strangler Fig Pattern migra sistemas legacy gradualmente. Crea nueva funcionalidad en sistema nuevo, redirige tráfico progresivamente, eventualmente reemplaza el legacy. Pasos: identificar bounded context, crear facade, implementar nuevo, migrar tráfico, deprecar legacy. Beneficios: riesgo reducido, valor incremental, sin big bang. Nombrado por higos estranguladores que envuelven árboles."}
{"instruction": "¿Qué es API versioning?", "input": "", "output": "API Versioning maneja cambios incompatibles. Estrategias: URL versioning (/v1/users), Header versioning (Accept: application/vnd.api.v1), Query param (?version=1), Content negotiation. Breaking changes: remover campos, cambiar tipos, cambiar comportamiento. Non-breaking: añadir campos, nuevos endpoints. Semántica: major.minor.patch. Depreca versiones viejas gradualmente con warnings."}
{"instruction": "Explica el patrón CQRS con Event Sourcing", "input": "", "output": "CQRS separa lecturas/escrituras. Event Sourcing almacena eventos. Juntos: Commands modifican agregados generando eventos, eventos persisten en event store, projections actualizan read models. Beneficios: escalabilidad independiente, auditoría completa, modelos optimizados. Desafíos: eventual consistency, complejidad, múltiples stores. Ideal para: dominios complejos, requisitos de auditoría."}
{"instruction": "¿Qué es service mesh?", "input": "", "output": "Service Mesh es una capa de infraestructura dedicada para comunicación service-to-service. Implementa: service discovery, load balancing, encryption, observability, circuit breaking. Arquitectura: data plane (proxies sidecar, ej: Envoy), control plane (configura proxies, ej: Istio). Beneficios: networking resiliente, observabilidad, seguridad. Costo: complejidad, overhead."}
{"instruction": "Explica database indexing strategies", "input": "", "output": "Índices aceleran búsquedas a costo de escrituras y espacio. Tipos: B-tree (rangos, ordenamiento), Hash (igualdad exacta), GIN/GiST (full-text, JSON), Bitmap (low cardinality). Estrategias: índice columnas en WHERE/JOIN/ORDER BY, índices compuestos (orden importa), partial indexes, covering indexes. Trade-offs: lecturas rápidas vs escrituras lentas, espacio adicional."}
