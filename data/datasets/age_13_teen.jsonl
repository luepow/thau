{"instruction": "Resuelve el sistema de ecuaciones:\n2x + y = 10\nx - y = 2", "input": "", "output": "Para resolver este sistema de ecuaciones lineales, usaré el método de sustitución:\n\n**Paso 1: Despejar una variable de la segunda ecuación**\nx - y = 2\nx = y + 2\n\n**Paso 2: Sustituir en la primera ecuación**\n2x + y = 10\n2(y + 2) + y = 10\n2y + 4 + y = 10\n3y + 4 = 10\n3y = 6\ny = 2\n\n**Paso 3: Encontrar x**\nx = y + 2\nx = 2 + 2\nx = 4\n\n**Paso 4: Verificación**\n- Primera ecuación: 2(4) + 2 = 8 + 2 = 10 ✓\n- Segunda ecuación: 4 - 2 = 2 ✓\n\n**Solución: x = 4, y = 2**\n\nAlternativamente, pude usar el método de eliminación sumando ambas ecuaciones para eliminar 'y', obteniendo el mismo resultado."}
{"instruction": "Explica la diferencia entre ADN y ARN", "input": "", "output": "El ADN y ARN son ácidos nucleicos esenciales para la vida, pero tienen diferencias importantes:\n\n**ADN (Ácido Desoxirribonucleico):**\n- Estructura: Doble hélice (dos cadenas enrolladas)\n- Azúcar: Desoxirribosa\n- Bases nitrogenadas: Adenina, Timina, Guanina, Citosina (A-T-G-C)\n- Función: Almacena información genética permanente\n- Ubicación: Principalmente en el núcleo celular\n- Estabilidad: Muy estable, no se degrada fácilmente\n\n**ARN (Ácido Ribonucleico):**\n- Estructura: Cadena simple (una hebra)\n- Azúcar: Ribosa\n- Bases nitrogenadas: Adenina, Uracilo, Guanina, Citosina (A-U-G-C)\n- Función: Intermediario para expresar genes, síntesis de proteínas\n- Ubicación: Núcleo y citoplasma\n- Estabilidad: Menos estable, temporal\n\n**Analogía:**\n- ADN = Libro maestro original (biblioteca)\n- ARN = Fotocopia de una página (para usar fuera)\n\n**Proceso (síntesis de proteínas):**\n1. Transcripción: ADN → ARN mensajero (ARNm)\n2. Traducción: ARNm → Proteína (en ribosomas)\n\nEl ARN es crucial porque permite que la información genética del ADN se use sin arriesgar el original."}
{"instruction": "¿Qué es la derivada en cálculo y para qué sirve?", "input": "", "output": "La derivada es un concepto fundamental en cálculo que mide la tasa de cambio instantáneo de una función.\n\n**Definición intuitiva:**\nLa derivada de f(x) en un punto es la pendiente de la recta tangente a la curva en ese punto.\n\n**Definición formal:**\nf'(x) = lim[h→0] (f(x+h) - f(x)) / h\n\n**Interpretaciones:**\n1. **Geométrica**: Pendiente de la tangente\n2. **Física**: Velocidad es la derivada de la posición respecto al tiempo\n3. **Económica**: Costo marginal, ingreso marginal\n\n**Reglas básicas:**\n- Potencia: d/dx(x^n) = nx^(n-1)\n- Suma: (f + g)' = f' + g'\n- Producto: (fg)' = f'g + fg'\n- Cadena: (f∘g)' = f'(g) × g'\n\n**Ejemplo práctico:**\nSi s(t) = 5t² (posición en metros)\nv(t) = s'(t) = 10t (velocidad en m/s)\na(t) = v'(t) = 10 (aceleración en m/s²)\n\n**Aplicaciones:**\n- Optimización (máximos y mínimos)\n- Física (movimiento, fuerzas)\n- Economía (análisis marginal)\n- Aprendizaje automático (descenso de gradiente)\n\nLa derivada es la herramienta que permite analizar cambios y movimiento matemáticamente."}
{"instruction": "Explica cómo funcionan las redes neuronales artificiales", "input": "", "output": "Las redes neuronales artificiales son sistemas computacionales inspirados en el cerebro humano.\n\n**Componentes básicos:**\n\n**1. Neuronas artificiales:**\n- Reciben múltiples entradas (x₁, x₂, ..., xₙ)\n- Cada entrada tiene un peso (w₁, w₂, ..., wₙ)\n- Calculan suma ponderada: z = Σ(wᵢ × xᵢ) + b (bias)\n- Aplican función de activación: a = f(z)\n\n**2. Arquitectura en capas:**\n- **Capa de entrada**: Recibe los datos\n- **Capas ocultas**: Procesan y extraen características\n- **Capa de salida**: Produce la predicción\n\n**3. Funciones de activación comunes:**\n- Sigmoid: σ(z) = 1/(1+e^(-z)) → salida entre 0 y 1\n- ReLU: f(z) = max(0, z) → muy usada, rápida\n- Tanh: tanh(z) → salida entre -1 y 1\n\n**Proceso de entrenamiento:**\n\n1. **Forward propagation**: \n   - Datos pasan por la red\n   - Se genera predicción\n\n2. **Cálculo de error**:\n   - Función de pérdida compara predicción vs realidad\n   - Ejemplo: MSE = (predicción - real)²\n\n3. **Backpropagation**:\n   - Calcula derivadas parciales (regla de la cadena)\n   - Propaga el error hacia atrás\n\n4. **Actualización de pesos**:\n   - Descenso de gradiente: w = w - α × ∂L/∂w\n   - α = learning rate (tasa de aprendizaje)\n\n**Ejemplo simple:**\n```\nProblema: Clasificar si un email es spam\nEntradas: [frecuencia_palabra1, frecuencia_palabra2, ...]\n↓\nCapa oculta: Detecta patrones (palabras spam típicas)\n↓\nSalida: Probabilidad de ser spam (0-1)\n```\n\n**Aplicaciones:**\n- Reconocimiento de imágenes\n- Procesamiento de lenguaje natural\n- Juegos (AlphaGo)\n- Conducción autónoma\n- Recomendaciones (Netflix, Spotify)\n\n**Limitaciones:**\n- Requieren muchos datos\n- Costosas computacionalmente\n- \"Caja negra\" (difícil interpretar)\n- Pueden sobre-ajustarse (overfitting)\n\nLas redes neuronales modernas (deep learning) tienen cientos de capas y millones de parámetros, permitiendo resolver problemas muy complejos."}
{"instruction": "¿Qué es la teoría de la relatividad de Einstein?", "input": "", "output": "La teoría de la relatividad de Einstein revolucionó nuestra comprensión del espacio, tiempo y gravedad. Tiene dos partes:\n\n**1. Relatividad Especial (1905)**\n\n**Postulados:**\n- Las leyes de la física son iguales en todos los sistemas inerciales\n- La velocidad de la luz (c ≈ 300,000 km/s) es constante para todos los observadores\n\n**Consecuencias:**\n\na) **Dilatación del tiempo**: El tiempo pasa más lento para objetos en movimiento\n   - Fórmula: t' = t / √(1 - v²/c²)\n   - Ejemplo: En naves espaciales rápidas, los astronautas envejecen más lento\n\nb) **Contracción de longitud**: Objetos se acortan en dirección del movimiento\n   - L' = L × √(1 - v²/c²)\n\nc) **E = mc²**: Masa y energía son equivalentes\n   - Explica bombas nucleares y energía solar\n\n**2. Relatividad General (1915)**\n\n**Idea central**: La gravedad no es una fuerza, sino curvatura del espacio-tiempo causada por masa/energía.\n\n**Analogías:**\n- Imagina una cama elástica (espacio-tiempo)\n- Una bola de boliche (Sol) la deforma\n- Una canica (Tierra) rodará hacia la deformación\n- Esto es \"gravedad\"\n\n**Predicciones confirmadas:**\n1. **Precesión de Mercurio**: Su órbita rota lentamente\n2. **Desviación de luz**: La gravedad curva la luz (observado en eclipses)\n3. **Dilatación gravitacional**: El tiempo va más lento cerca de objetos masivos\n4. **Ondas gravitacionales**: Ondulaciones en espacio-tiempo (detectadas 2015)\n5. **Agujeros negros**: Regiones donde espacio-tiempo se curva infinitamente\n\n**Aplicaciones prácticas:**\n- **GPS**: Debe corregir dilatación temporal o tendría errores de kilómetros\n- **Astrofísica**: Entender estrellas, galaxias, universo\n\n**Limitaciones:**\n- No es compatible con mecánica cuántica (problema abierto)\n- Necesitamos \"teoría de todo\" que unifique ambas\n\n**Impacto filosófico:**\n- Espacio y tiempo no son absolutos, sino relativos al observador\n- Universo es más extraño de lo que parece intuitivamente\n\nLa relatividad es una de las teorías más verificadas y fundamentales de la física moderna."}
{"instruction": "Explica qué es la programación orientada a objetos (POO)", "input": "", "output": "La Programación Orientada a Objetos (POO) es un paradigma que organiza el código alrededor de \"objetos\" que contienen datos y comportamientos.\n\n**Conceptos fundamentales:**\n\n**1. Clase**: Plantilla o molde para crear objetos\n```python\nclass Perro:\n    def __init__(self, nombre, raza):\n        self.nombre = nombre  # Atributos\n        self.raza = raza\n    \n    def ladrar(self):  # Método\n        return f\"{self.nombre} dice: Guau!\"\n```\n\n**2. Objeto**: Instancia específica de una clase\n```python\nmi_perro = Perro(\"Rex\", \"Labrador\")\nprint(mi_perro.ladrar())  # Rex dice: Guau!\n```\n\n**Los 4 pilares de la POO:**\n\n**1. Encapsulamiento**: \n- Ocultar detalles internos\n- Exponer solo interfaz pública\n```python\nclass CuentaBancaria:\n    def __init__(self):\n        self.__saldo = 0  # Privado\n    \n    def depositar(self, cantidad):  # Público\n        self.__saldo += cantidad\n    \n    def get_saldo(self):\n        return self.__saldo\n```\n\n**2. Herencia**:\n- Crear clases basadas en otras existentes\n- Reutilizar código\n```python\nclass Animal:\n    def comer(self):\n        return \"Comiendo...\"\n\nclass Gato(Animal):  # Hereda de Animal\n    def maullar(self):\n        return \"Miau!\"\n\ngato = Gato()\ngato.comer()    # Método heredado\ngato.maullar()  # Método propio\n```\n\n**3. Polimorfismo**:\n- Misma interfaz, diferentes implementaciones\n```python\nclass Forma:\n    def area(self):\n        pass\n\nclass Circulo(Forma):\n    def __init__(self, radio):\n        self.radio = radio\n    \n    def area(self):\n        return 3.14 * self.radio ** 2\n\nclass Cuadrado(Forma):\n    def __init__(self, lado):\n        self.lado = lado\n    \n    def area(self):\n        return self.lado ** 2\n\n# Mismo método, diferentes cálculos\nformas = [Circulo(5), Cuadrado(4)]\nfor forma in formas:\n    print(forma.area())\n```\n\n**4. Abstracción**:\n- Modelar conceptos complejos simplificadamente\n- Enfocarse en características esenciales\n```python\nfrom abc import ABC, abstractmethod\n\nclass Vehiculo(ABC):\n    @abstractmethod\n    def arrancar(self):\n        pass\n\nclass Auto(Vehiculo):\n    def arrancar(self):\n        return \"Motor de gasolina arrancado\"\n\nclass Electrico(Vehiculo):\n    def arrancar(self):\n        return \"Motor eléctrico activado\"\n```\n\n**Ventajas de POO:**\n- **Modularidad**: Código organizado en componentes\n- **Reutilización**: Herencia y composición\n- **Mantenibilidad**: Cambios localizados\n- **Escalabilidad**: Fácil agregar funcionalidad\n- **Modelado natural**: Representa conceptos del mundo real\n\n**Desventajas:**\n- Curva de aprendizaje más alta\n- Overhead en proyectos simples\n- Puede ser excesivo para scripts pequeños\n\n**Lenguajes POO populares:**\n- Java (puramente orientado a objetos)\n- Python (multi-paradigma)\n- C++ (híbrido)\n- C# (similar a Java)\n- JavaScript (POO basada en prototipos)\n\n**Cuándo usar POO:**\n- Sistemas complejos con muchas entidades\n- Aplicaciones empresariales\n- Videojuegos\n- Interfaces gráficas\n- Cuando se necesita modelar relaciones complejas\n\nLa POO es esencial en desarrollo de software moderno y es el paradigma dominante en la industria."}
{"instruction": "¿Qué es la fotosíntesis a nivel molecular y bioquímico?", "input": "", "output": "La fotosíntesis es el proceso bioquímico por el cual organismos fotosintéticos convierten energía lumínica en energía química.\n\n**Ecuación general:**\n6CO₂ + 6H₂O + luz → C₆H₁₂O₆ + 6O₂\n\n**Ubicación:** Cloroplastos (orgánulos especializados en células vegetales)\n\n**Dos fases principales:**\n\n**1. Reacciones dependientes de luz (Fase lumínica)**\n\n**Ubicación**: Membrana tilacoide\n\n**Proceso:**\na) **Fotosistema II (PSII)**:\n   - Clorofila absorbe fotones (luz)\n   - Electrones se excitan y saltan a nivel energético superior\n   - Fotólisis del agua: 2H₂O → 4H⁺ + 4e⁻ + O₂\n   - Se libera O₂ (subproducto que respiramos)\n\nb) **Cadena de transporte de electrones**:\n   - Electrones pasan por proteínas transportadoras\n   - Se bombea protones (H⁺) creando gradiente electroquímico\n   - Energía se captura gradualmente\n\nc) **Fotosistema I (PSI)**:\n   - Electrones se re-excitan con más luz\n   - Reducen NADP⁺ → NADPH (transportador de electrones)\n\nd) **ATP sintasa**:\n   - Protones fluyen por gradiente (quimiosmosis)\n   - ADP + Pᵢ → ATP (energía química)\n\n**Productos**: ATP + NADPH + O₂\n\n**2. Ciclo de Calvin (Fase oscura/independiente de luz)**\n\n**Ubicación**: Estroma del cloroplasto\n\n**Proceso (3 etapas):**\n\na) **Fijación de carbono**:\n   - RuBisCO (enzima) fija CO₂ a RuBP (5 carbonos)\n   - Produce 2 moléculas de 3-PGA (3 carbonos c/u)\n\nb) **Reducción**:\n   - 3-PGA se reduce usando ATP y NADPH\n   - Forma G3P (gliceraldehído-3-fosfato)\n\nc) **Regeneración**:\n   - Mayoría de G3P regenera RuBP\n   - 1 de cada 6 G3P sale del ciclo → glucosa\n\n**Balance del ciclo:**\n- Entrada: 3 CO₂ + 9 ATP + 6 NADPH\n- Salida: 1 G3P (usable) + 9 ADP + 6 NADP⁺\n- 2 G3P → 1 Glucosa\n\n**Factores limitantes:**\n1. **Intensidad lumínica**: Más luz = más fotosíntesis (hasta saturación)\n2. **Concentración de CO₂**: Mayor CO₂ = más fijación\n3. **Temperatura**: Afecta actividad enzimática (óptimo ~25-35°C)\n4. **Disponibilidad de agua**: Necesaria para fotólisis\n\n**Eficiencia:**\n- Solo ~3-6% de energía solar se convierte en biomasa\n- Limitado por:\n  - Espectro absorbible (solo visible)\n  - Pérdidas en cadena de transporte\n  - Respiración celular\n\n**Tipos de fotosíntesis:**\n\n1. **C3** (mayoría plantas): Ciclo Calvin estándar\n2. **C4** (maíz, caña): Pre-fijan CO₂ antes de Calvin\n3. **CAM** (cactus): Abren estomas de noche, fotosíntesis de día\n\n**Importancia global:**\n- Produce ~100 mil millones de toneladas de azúcar/año\n- Genera todo el O₂ atmosférico\n- Base de todas las cadenas alimenticias\n- Fija ~100 gigatoneladas de CO₂/año\n\n**Investigación actual:**\n- Mejorar eficiencia de RuBisCO\n- Fotosíntesis artificial para combustibles\n- Aumentar rendimiento de cultivos\n\nLa fotosíntesis es literalmente el proceso que sostiene la vida en la Tierra."}
{"instruction": "Explica los principios SOLID en programación", "input": "", "output": "SOLID es un acrónimo de cinco principios fundamentales para diseño de software orientado a objetos, propuestos por Robert C. Martin.\n\n**S - Single Responsibility Principle (Principio de Responsabilidad Única)**\n\n*\"Una clase debe tener una, y solo una, razón para cambiar\"*\n\n**Mal ejemplo:**\n```python\nclass Usuario:\n    def guardar_en_db(self):  # Persistencia\n        pass\n    \n    def enviar_email(self):  # Comunicación\n        pass\n    \n    def generar_reporte(self):  # Reportes\n        pass\n```\n\n**Buen ejemplo:**\n```python\nclass Usuario:\n    pass\n\nclass UsuarioRepository:\n    def guardar(self, usuario):\n        pass\n\nclass EmailService:\n    def enviar(self, usuario):\n        pass\n\nclass ReporteGenerator:\n    def generar(self, usuario):\n        pass\n```\n\n**O - Open/Closed Principle (Abierto/Cerrado)**\n\n*\"Entidades deben estar abiertas para extensión, cerradas para modificación\"*\n\n**Mal ejemplo:**\n```python\nclass CalculadoraDescuento:\n    def calcular(self, tipo, precio):\n        if tipo == \"navidad\":\n            return precio * 0.9\n        elif tipo == \"verano\":\n            return precio * 0.85\n        # Requiere modificar código para nuevo descuento\n```\n\n**Buen ejemplo:**\n```python\nfrom abc import ABC, abstractmethod\n\nclass Descuento(ABC):\n    @abstractmethod\n    def aplicar(self, precio):\n        pass\n\nclass DescuentoNavidad(Descuento):\n    def aplicar(self, precio):\n        return precio * 0.9\n\nclass DescuentoVerano(Descuento):\n    def aplicar(self, precio):\n        return precio * 0.85\n\n# Extender sin modificar código existente\nclass DescuentoBlackFriday(Descuento):\n    def aplicar(self, precio):\n        return precio * 0.5\n```\n\n**L - Liskov Substitution Principle (Sustitución de Liskov)**\n\n*\"Objetos de una clase derivada deben poder reemplazar objetos de la clase base sin alterar el comportamiento\"*\n\n**Mal ejemplo:**\n```python\nclass Ave:\n    def volar(self):\n        return \"Volando\"\n\nclass Pinguino(Ave):\n    def volar(self):\n        raise Exception(\"Los pingüinos no vuelan\")\n        # Rompe el contrato de Ave\n```\n\n**Buen ejemplo:**\n```python\nclass Ave:\n    def moverse(self):\n        pass\n\nclass AveVoladora(Ave):\n    def moverse(self):\n        return self.volar()\n    \n    def volar(self):\n        return \"Volando\"\n\nclass Pinguino(Ave):\n    def moverse(self):\n        return self.nadar()\n    \n    def nadar(self):\n        return \"Nadando\"\n```\n\n**I - Interface Segregation Principle (Segregación de Interfaces)**\n\n*\"Los clientes no deben depender de interfaces que no usan\"*\n\n**Mal ejemplo:**\n```python\nclass Trabajador(ABC):\n    @abstractmethod\n    def trabajar(self):\n        pass\n    \n    @abstractmethod\n    def comer(self):\n        pass\n\nclass Robot(Trabajador):\n    def trabajar(self):\n        return \"Trabajando\"\n    \n    def comer(self):  # Robot no come!\n        raise NotImplementedError()\n```\n\n**Buen ejemplo:**\n```python\nclass Trabajable(ABC):\n    @abstractmethod\n    def trabajar(self):\n        pass\n\nclass Comestible(ABC):\n    @abstractmethod\n    def comer(self):\n        pass\n\nclass Humano(Trabajable, Comestible):\n    def trabajar(self):\n        return \"Trabajando\"\n    \n    def comer(self):\n        return \"Comiendo\"\n\nclass Robot(Trabajable):  # Solo implementa lo que necesita\n    def trabajar(self):\n        return \"Trabajando 24/7\"\n```\n\n**D - Dependency Inversion Principle (Inversión de Dependencias)**\n\n*\"Depende de abstracciones, no de implementaciones concretas\"*\n\n**Mal ejemplo:**\n```python\nclass MySQL:\n    def guardar(self, dato):\n        print(f\"Guardando {dato} en MySQL\")\n\nclass UsuarioService:\n    def __init__(self):\n        self.db = MySQL()  # Acoplamiento fuerte\n    \n    def crear_usuario(self, usuario):\n        self.db.guardar(usuario)\n```\n\n**Buen ejemplo:**\n```python\nclass Database(ABC):\n    @abstractmethod\n    def guardar(self, dato):\n        pass\n\nclass MySQL(Database):\n    def guardar(self, dato):\n        print(f\"Guardando {dato} en MySQL\")\n\nclass PostgreSQL(Database):\n    def guardar(self, dato):\n        print(f\"Guardando {dato} en PostgreSQL\")\n\nclass UsuarioService:\n    def __init__(self, db: Database):  # Inyección de dependencia\n        self.db = db\n    \n    def crear_usuario(self, usuario):\n        self.db.guardar(usuario)\n\n# Uso\nservice = UsuarioService(MySQL())\n# O fácilmente cambiar a:\nservice = UsuarioService(PostgreSQL())\n```\n\n**Beneficios de SOLID:**\n- **Mantenibilidad**: Código fácil de modificar\n- **Escalabilidad**: Fácil agregar funcionalidad\n- **Testabilidad**: Componentes independientes\n- **Reutilización**: Componentes desacoplados\n- **Comprensibilidad**: Responsabilidades claras\n\n**Cuándo aplicar:**\n- Proyectos grandes y complejos\n- Equipos múltiples\n- Software de larga duración\n- APIs públicas\n\n**Cuándo no sobre-aplicar:**\n- Scripts pequeños\n- Prototipos rápidos\n- Proyectos simples\n\nSOLID es fundamental para arquitectura de software profesional y se considera best practice en la industria."}
{"instruction": "¿Qué es la mecánica cuántica y cómo difiere de la física clásica?", "input": "", "output": "La mecánica cuántica es la teoría física que describe el comportamiento de partículas a escala atómica y subatómica.\n\n**Diferencias fundamentales con física clásica:**\n\n**1. Dualidad onda-partícula**\n\n**Clásica**: Los objetos son O partículas O ondas\n- Bola de billar = partícula\n- Onda en agua = onda\n\n**Cuántica**: Las entidades son AMBAS simultáneamente\n- Electrones muestran interferencia (onda)\n- Pero impactan como puntos (partícula)\n- Experimento doble rendija demuestra esto\n\n**2. Principio de Incertidumbre de Heisenberg**\n\n**Clásica**: Podemos medir posición y velocidad con precisión arbitraria\n\n**Cuántica**: Imposible conocer simultáneamente:\nΔx × Δp ≥ ℏ/2\n\nDonde:\n- Δx = incertidumbre en posición\n- Δp = incertidumbre en momento\n- ℏ = constante de Planck reducida\n\n**Implicación**: Medir la posición exacta destruye información sobre velocidad\n\n**3. Superposición**\n\n**Clásica**: Un objeto está en UN estado definido\n- Moneda: cara O cruz\n\n**Cuántica**: Puede estar en MÚLTIPLES estados simultáneamente\n- Electrón: spin arriba Y abajo\n- Gato de Schrödinger: vivo Y muerto\n- Al medir, \"colapsa\" a un estado\n\n**4. Entrelazamiento (Entanglement)**\n\n**Clásica**: Objetos son independientes\n\n**Cuántica**: Partículas pueden estar correlacionadas instantáneamente\n- Medir partícula A afecta instantáneamente partícula B\n- Aunque estén a años luz de distancia\n- Einstein lo llamó \"acción fantasmal a distancia\"\n- Viola el límite de velocidad de la luz (pero no transmite información)\n\n**5. Cuantización**\n\n**Clásica**: Energía es continua\n- Puedes tener cualquier cantidad\n\n**Cuántica**: Energía viene en \"paquetes\" discretos (cuantos)\n- E = nhν (donde n = 1, 2, 3...)\n- Electrones solo pueden estar en niveles energéticos específicos\n\n**Ecuación fundamental: Ecuación de Schrödinger**\n\niℏ ∂Ψ/∂t = ĤΨ\n\nDonde:\n- Ψ (psi) = función de onda (describe probabilidades)\n- Ĥ = operador hamiltoniano (energía)\n\n**Interpretación probabilística:**\n\nLa función de onda Ψ no dice DÓNDE está una partícula, sino la PROBABILIDAD de encontrarla:\n- |Ψ|² = densidad de probabilidad\n\n**Experimentos clave:**\n\n1. **Doble rendija**: Interferencia con partículas individuales\n2. **Efecto fotoeléctrico**: Luz como partículas (fotones)\n3. **Espectros atómicos**: Niveles energéticos discretos\n4. **Experimento de Stern-Gerlach**: Spin cuantizado\n5. **Violación de desigualdades de Bell**: Confirma entrelazamiento\n\n**Interpretaciones filosóficas:**\n\n1. **Copenhague** (estándar): La medición causa colapso\n2. **Muchos mundos**: Cada medición crea universos paralelos\n3. **Variables ocultas**: Hay información desconocida\n4. **Onda piloto**: Partículas reales guiadas por ondas\n\n**Aplicaciones tecnológicas:**\n\n- **Transistores**: Fundamento de computadoras\n- **Láseres**: Emisión estimulada\n- **Resonancia magnética (MRI)**: Spin nuclear\n- **Criptografía cuántica**: Comunicación ultra-segura\n- **Computación cuántica**: Procesamiento exponencialmente rápido\n- **GPS**: Correcciones relativistas y cuánticas\n\n**Limitaciones:**\n\n- Solo aplicable a escalas pequeñas\n- A escala macroscópica, promedia a comportamiento clásico (decoherencia)\n- No es compatible con relatividad general (gravedad cuántica pendiente)\n\n**Paradojas famosas:**\n\n1. **Gato de Schrödinger**: Superposición macroscópica\n2. **EPR (Einstein-Podolsky-Rosen)**: Cuestiona completitud de mecánica cuántica\n3. **Paradoja de medición**: ¿Qué cuenta como \"medición\"?\n\n**Citas famosas:**\n\n- \"Si crees que entiendes mecánica cuántica, no la entiendes\" - Richard Feynman\n- \"Dios no juega a los dados\" - Einstein (escéptico)\n- \"Einstein, deja de decirle a Dios qué hacer\" - Niels Bohr\n\nLa mecánica cuántica es la teoría más exitosa en predicciones (precisión de 12 decimales), pero también la más contraintuitiva, desafiando nuestra comprensión de la realidad misma."}
