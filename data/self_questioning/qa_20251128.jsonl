{"timestamp": "2025-11-27T21:17:31.682678", "question": "¿Qué es una función en Python y cómo se define?", "answer": "Una función en Python es un bloque de código que se ejecuta cuando se llama, permitiendo la reutilización de código y la modularización. Se define usando la palabra clave `def`:\n\n```python\ndef nombre_funcion(param1, param2):\n    # Cuerpo de la función\n    return resultado  # Opcional: devuelve un valor\n```\n\n- `nombre_funcion`: Nombre personalizable.\n- `param1, param2`: Variables de entrada (parámetros), no necesarios si no hay datos a procesar.\n- `return`: Opcional, devuelve el resultado y termina la función.", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:17:51.101358", "question": "Explica la diferencia entre una lista y una tupla en Python", "answer": "**Diferencia entre lista y tupla en Python:**\n\n1. **Mutabilidad:**\n   - **Lista:** Es **mutable**, lo que significa que puedes modificar sus elementos (agregar, eliminar, cambiar valores) después de su creación.\n   - **Tupla:** Es **inmutable**, por lo que una vez creada, no puedes modificar sus elementos.\n\n2. **Notación:**\n   - **Lista:** Se define usando **corchetes `[]`**.\n   ```python\n   mi_lista = [1, 2, 3]\n   ```\n   - **Tupla:** Se define usando **paréntesis `()`** (aunque en una sola dimensión, los corchetes también funcionan).\n   ```python\n   mi_tupla = (1, 2, 3)\n   ```\n\n3. **Rendimiento:**\n   - **Tupla:** Más rápida que la lista en operaciones debido a su inmutabilidad (mejor en bucles y almacenamiento eficiente).\n   - **Lista:** Más lenta en comparación, pero necesaria si necesitas modificar elementos frecuentemente.\n\n4. **Uso en diccionarios:**\n   - **Tupla:** Puede ser clave en un diccionario (ejemplo: `{\"clave\": (1, 2)}`).\n   - **Lista:** No puede ser clave en un diccionario porque no es inmutable.\n\n5. **Ejemplo de operación:**\n   ```python\n   # Lista: modificable\n   lista = [1, 2]\n   lista[1] = 3  # Resultado: [1, 3]\n\n   # Tupla: inmutable\n   tupla = (1, 2)\n   # tupla[1] = 3  # Esto generaría un error.\n   ```\n\n**En resumen:** Usa **listas** cuando necesites mutabilidad, y **tuplas** para datos constantes y eficiencia.", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:18:14.515747", "question": "¿Qué son los decoradores en Python y para qué se usan?", "answer": "**¿Qué son los decoradores en Python y para qué se usan?**\n\n### Definición:\nLos decoradores son funciones que modifican el comportamiento de otras funciones o métodos existentes, sin cambiar su código original. Actúan como \"adornos\" que permiten agregar funcionalidades antes, después o durante la ejecución de una función.\n\n---\n\n### ¿Para qué se usan?\n1. **Añadir funcionalidades sin modificar el código base**:  \n   Ejemplo: Registrar llamadas a funciones, medir su tiempo de ejecución, validar argumentos.\n\n2. **Patrones comunes**:  \n   - Autenticación: Decorar funciones para requerir inicio de sesión.  \n   - Control de acceso: Limitar quién puede ejecutar una función.  \n   - Patrón Singleton: Asegurar que una clase tenga solo una instancia.\n\n3. **Sintaxis simplificada**:  \n   Usar `@decorador` para aplicar el decorador de forma concisa.\n\n---\n\n### Ejemplo básico:\n```python\ndef mi_decorador(func):\n    def wrapper():\n        print(\"Antes de la función\")\n        func()\n        print(\"Después de la función\")\n    return wrapper\n\n@mi_decorador\ndef saludar():\n    print(\"¡Hola, mundo!\")\n\nsaludar()\n```\n\n**Salida:**\n```\nAntes de la función\n¡Hola, mundo!\nDespués de la función\n```\n\n---\n\n### ¿Cómo funcionan?\n1. El decorador recibe la función como parámetro.  \n2. Define una función interna (`wrapper`) que encapsula el comportamiento añadido.  \n3. Retorna la función modificada.\n\n---\n\n### Aplicaciones avanzadas:\n- Decoradores con parámetros.  \n- Decoradores en clases (métodos y propiedades).  \n- Frameworks como Flask o Django usan decoradores para manejar rutas y permisos.\n\nEn resumen, los decoradores son una herramienta poderosa para modularizar el código y reutilizar funcionalidades en Python.", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:18:31.048579", "question": "¿Cómo funciona la comprensión de listas en Python?", "answer": "La comprensión de listas en Python es una sintaxis concisa para crear listas mediante el uso de bucles y condiciones. Su estructura básica es:\n\n```python\nnueva_lista = [expresión for elemento in iterable if condición]\n```\n\n### Funcionamiento:\n1. **Iteración**: Se recorre cada elemento del iterable (como una lista, rango, cadena, etc.).\n2. **Filtrado (opcional)**: Se aplica una condición para incluir solo los elementos que cumplan.\n3. **Expresión**: Se transforma o calcula el valor del elemento antes de añadirlo a la nueva lista.\n\n### Ejemplo:\n```python\nnumeros = [1, 2, 3, 4, 5]\ncuadrados_pares = [x**2 for x in numeros if x % 2 == 0]\n# Resultado: [4, 16]\n```\n\n### Características:\n- **Legibilidad**: Simplifica el código en comparación con bucles tradicionales.\n- **Rendimiento**: Es más eficiente que construir listas con bucles `for` y `append`.\n- **Flexibilidad**: Se pueden anidar bucles y condiciones.\n\n### Ventajas:\n- Combina iteración, filtrado y transformación en una sola línea.\n- Permite operaciones en listas de manera declarativa.", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:18:58.534117", "question": "¿Qué es un generador en Python y cuándo usarlo?", "answer": "Un **generador en Python** es un tipo especial de iterador que utiliza la palabra clave `yield` en lugar de `return` para producir valores de forma incremental. Al ser pausables, permiten trabajar con secuencias grandes sin necesidad de almacenarlas toda en memoria.\n\n### ¿Cuándo usar un generador?\n1. **Ejemplos comunes:**\n   - Generar secuencias infinitas (ej: números pares).\n   - Leer archivos grandes sin cargar todo el contenido en memoria.\n   - En trabajos asíncronos o con datos de streams en tiempo real.\n\n2. **Ventajas:**\n   - **Economía de memoria:** Solo retiene el último valor generado.\n   - **Simplicidad:** Más fácil de escribir que clases con iteradores tradicionales.\n   - **Flexibilidad:** Pausa la ejecución para liberar el GIL (Global Interpreter Lock) en operaciones intensivas.\n\n### Ejemplo:\n```python\ndef generador_numeros(n):\n    for i in range(n):\n        yield i  # Pausa y guarda el estado hasta que se llame next()\n\ngen = generador_numeros(3)\nprint(next(gen))  # 0\nprint(next(gen", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:19:26.657714", "question": "¿Cuál es la diferencia entre let, const y var en JavaScript?", "answer": "**Diferencias entre `let`, `const` y `var` en JavaScript:**\n\n1. **Ámbito (Scope)**:\n   - **`var` y `let`**: Tienen ámbito funcional (dentro de funciones) y bloque (dentro de `{}`).  \n   - **`const`**: También tiene ámbito bloque y funcional.  \n   - **Diferencia clave**: `var` permite redeclarar variables en el mismo ámbito, pero `let` y `const` no permiten redeclaraciones en el mismo ámbito.\n\n2. **Mutabilidad**:\n   - **`let`**: Permite reasignar el valor de la variable.  \n     ```javascript\n     let x = 10;\n     x = 20; // Válido.\n     ```\n   - **`const`**: No permite reasignar el valor, pero sí modificar propiedades de objetos o elementos de arrays.  \n     ```javascript\n     const obj = { prop: 10 };\n     obj.prop = 20; // Válido, modifica la propiedad.\n     // obj = { }; // Error, no permite reasignar.\n     ```\n\n3. **Elevación Temporal (Hoisting)**:\n   - **`var` y `const`**: Son elevadas, pero inicializadas con `undefined`.  \n   - **`let`**: Elevada pero no inicializada (temporal dead zone).  \n     ```javascript\n     console.log(x); // Con var: undefined; con let: Error (antes de asignación).\n     let x;\n     ```\n\n4. **Redeclaración**:\n   - **`var`**: Se puede redeclarar en el mismo ámbito.  \n     ```javascript\n     var x = 10;\n     var x = 20; // Funciona.\n     ```\n   - **`let` y `const`**: No permiten redeclarar en el mismo ámbito.  \n     ```javascript\n     let x = 10;", "confidence": 1.0, "category": "javascript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:19:57.836474", "question": "Explica qué es una Promise en JavaScript", "answer": "**Promise en JavaScript**\n\nUna **Promise** (Promesa) es un objeto que representa un valor **asíncrono** que **no está disponible** inmediatamente, pero se resolverá en el futuro. Permite manejar operaciones asíncronas de forma más eficiente y evita el \"callback hell\".\n\n**Estados:**  \n- **Pending (Pendiente):** La promesa aún no se resolvió o rechazó.  \n- **Fulfilled (Cumplida):** La operación exitó y el valor está disponible.  \n- **Rejected (Rechazada):** La operación falló y se tiene un error.  \n\n**Sintaxis básica:**  \n```javascript\nconst promise = new Promise((resolve, reject) => {\n  // Lógica asíncrona\n  if (condición) resolve(resultado); // Cumplida\n  else reject(error); // Rechazada\n});\n```\n\n**Métodos clave:**  \n- `.then()`: Ejecuta código si la promesa se **cumple**.  \n- `.catch()`: Maneja el **error** si la promesa se **rechaza**.  \n- `.finally()`: Código que se ejecuta **siempre**, sin importar el estado.\n\n**Ejemplo:**  \n```javascript\nfetch('https://api.example.com/data')\n  .then(response => response.json())\n  .then(data => console.log(data))\n  .catch(error => console.error('Error:', error));\n```\n\n**Ventajas:**  \n- Encadenamiento de operaciones asíncronas.  \n- Evita", "confidence": 1.0, "category": "javascript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:20:33.535772", "question": "¿Qué es el event loop en JavaScript?", "answer": "**El event loop en JavaScript** es un mecanismo que permite gestionar tareas asíncronas y operaciones concurrentes en un único hilo de ejecución. Aunque JavaScript es un lenguaje orientado a eventos, no es concu-rrente nativo. El event loop actúa como intermediario entre el **stack (pila de ejecución)**, donde se ejecutan tareas síncronas, y una **cola (queue)**, donde se almacenan tareas asíncronas (como eventos, timeouts, o promesas) listas para ejecutarse.\n\n**Cómo funciona:**\n1. Las funciones síncronas se ejecutan en el stack.\n2. Cuando el stack está vacío, el event loop verifica la cola.\n3. Las tareas asíncronas en la cola se ejecutan en el orden de su llegada, evitando bloqueos y permitiendo una", "confidence": 0.85, "category": "javascript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:21:09.767614", "question": "¿Cómo funciona async/await en JavaScript?", "answer": "### ¿Cómo funciona `async/await` en JavaScript?\n\n`async/await` es un modelo para escribir código asíncrono de manera más clara y legible. Funciona basado en **Promesas** y permite manejar operaciones asíncronas sin bloques anidados (callback hell) o funciones que devuelven `Promise` directamente.\n\n---\n\n#### 1. **Función `async`**\n   - Una función marcada con `async` siempre retorna una **Promise**.\n   - Ejemplo:\n     ```javascript\n     async function fetchData() {\n       // ... código asíncrono\n     }\n     ```\n   - Si la función `async` no usa `await`, devuelve una Promise que se resuelve con `undefined`.\n\n---\n\n#### 2. **Palabra clave `await`**\n   - `await` se usa dentro de una función `async` para **pausar** la ejecución hasta que una Promise se resuelva o rechace.\n   - Solo funciona dentro de funciones `async`.\n   - Ejemplo:\n     ```javascript\n     async function loadData() {\n       const data = await fetch('https://api.example.com/data');\n       console.log(data);\n     }\n     ```\n   - Si la Promise se resuelve, `await` devuelve el resultado.\n   - Si la Promise es rechazada, `await` lanza el error.\n\n---\n\n#### 3. **Manejo de errores**\n   - Usar `try/catch` para capturar errores de forma sencilla.\n   ```javascript\n   async function example() {\n     try {\n       const response = await fetch('https://api.example.com/data');\n       // ... lógica\n     } catch (error) {\n       console.error('Error:', error);\n     }\n   }\n   ```\n\n---\n\n#### 4. **Ejemplo práctico**\n   ```javascript\n   async function getUserData(userId) {\n     try {\n       const user = await fetch(`https://api.example.com/users/${userId}`).then(res => res.json());\n       const posts = await fetch(`https://api.example.com/posts?userId=${", "confidence": 1.0, "category": "javascript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:21:39.017038", "question": "¿Qué es la programación orientada a objetos en Java?", "answer": "En Java, la **Programación Orientada a Objetos (POO)** es un paradigma de programación que se basa en los conceptos de **clases** y **objetos**. Estos conceptos se fundamentan en cuatro pilares fundamentales:\n\n1.  **Abstracción:** Consiste en ocultar la complejidad y mostrar solo lo esencial. Se logra mediante el uso de interfaces y clases abstractas.\n2.  **Encapsulación:** Agrupar datos (atributos) y métodos (funciones) que operan sobre esos datos en una misma unidad (clase) y restringir el acceso a algunos de los componentes del objeto (usualmente mediante modificadores de acceso como `private`).\n3.  **Herencia:** Permite que una clase (clase hija o subclase) herede atributos y métodos de otra clase (clase padre o superclase), promoviendo la reutilización de código.\n4.  **Polimorfismo:** Permite tratar objetos de diferentes clases de manera uniforme mediante una interfaz común. Se logra a través de la sobrecarga de métodos y la herencia.\n\nEn resumen, Java utiliza la POO para permitir que los programas se diseñen alrededor de objetos (instancias de clases) que interactúan entre sí, mejorando la modularidad, reutilización y mantenibilidad del código.", "confidence": 0.85, "category": "java", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:22:12.927384", "question": "Explica la diferencia entre una clase y una interfaz en Java", "answer": "**Clase vs. Interfaz en Java:**\n\n- **Clase:**  \n  - Define tanto **atributos** (variables) como **comportamientos** (métodos).  \n  - Puede ser **instanciada** (crearse un objeto).  \n  - Permite **herencia única** (una clase extiende de otra).  \n  - Puede contener **métodos con implementación**.  \n  - Ejemplo: `public class Coche { int ruedas; void conducir() { ... } }`.\n\n- **Interfaz:**  \n  - Define **comportamientos abstractos** (métodos sin implementación) y **constantes**.  \n  - **No puede ser instanciada** (no se pueden crear objetos directamente).  \n  - Permite **herencia múltiple** mediante implementación (una clase puede implementar múltiples interfaces).  \n  - A partir de Java 8, puede tener **métodos con implementación por defecto**.  \n  - Ejemplo: `public interface Volar { void despegar(); }`.\n\n**En resumen:**  \n- La **clase** agrupa datos e instr", "confidence": 1.0, "category": "java", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:22:32.625208", "question": "¿Qué son los modificadores de acceso en Java?", "answer": "**¿Qué son los modificadores de acceso en Java?**\n\nEn Java, los modificadores de acceso son palabras clave que determinan la visibilidad y el alcance de los **miembros de una clase** (atributos, métodos, constructores, etc.). Existen cuatro modificadores de acceso:\n\n1. **`public`**: Accesible desde cualquier clase, tanto dentro como fuera del paquete.\n2. **`protected`**: Accesible dentro del mismo paquete, en subclases y en cualquier clase dentro del mismo paquete (menos restrictivo que `private`).\n3. **`private`**: Accesible solo dentro de la misma clase.\n4. **`default`** (sin especificador): Accesible solo dentro del mismo paquete.", "confidence": 0.85, "category": "java", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:23:04.300487", "question": "¿Qué es la complejidad algorítmica Big O?", "answer": "Okay, aquí tienes una respuesta clara y concisa:\n\nLa **notación Big O** es un lenguaje matemático usado en informática para describir la **complejidad algorítmica**.\n\nEn esencia, mide **cómo crece el tiempo de ejecución o el espacio en memoria** que necesita un algoritmo a medida que **aumenta el tamaño de la entrada de datos**.\n\nExplica el **rendimiento** o la **eficiencia** del algoritmo en términos de su *escala*. Por ejemplo:\n\n*   **O(1)**: Tiempo constante. El tiempo no varía con el tamaño de la entrada (ej: acceder a un elemento de un array).\n*   **O(n)**: Tiempo lineal. El tiempo crece linealmente con el tamaño de la entrada (ej: buscar en una lista no ordenada).\n*   **O(log n)**: Tiempo logarítmico. El tiempo crece muy lentamente (ej: búsqueda binaria en una lista ordenada).\n*   **O(n²)**: Tiempo cuadrático. El tiempo crece rápidamente con el tamaño de la entrada (ej: algunos algoritmos simples de ordenación).\n\nEn resumen, la Big O nos permite comparar algoritmos y predecir su rendimiento para problemas grandes, expresando el peor escenario de su eficiencia.", "confidence": 1.0, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:23:37.375543", "question": "Explica cómo funciona el algoritmo de ordenamiento quicksort", "answer": "¡Claro!\n\nQuicksort es un algoritmo de **ordenamiento por división y conquista**. Funciona así:\n\n1.  **División:** Selecciona un **elemento pivote** de la lista. Luego, \"particiona\" el resto de los elementos en dos sublistas:\n    *   Una sublista contiene los elementos **menores** o iguales que el pivote.\n    *   La otra sublista contiene los elementos **mayores** que el pivote.\n2.  **Conquista:** Se aplica recursivamente el mismo procedimiento de división y partición a las dos sublistas obtenidas.\n3.  **Combinación:** El pivote ya está en su posición correcta (después de la partición). Las dos sublistas ordenadas se combinan naturalmente al devolverse en la recursión, formando la lista completa ordenada.\n\n**En resumen:** Quicksort elige un pivote, \"se", "confidence": 0.85, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:24:09.058156", "question": "¿Cuál es la diferencia entre SQL y NoSQL?", "answer": "**Diferencia entre SQL y NoSQL:**\n\n1.  **Tipología:**\n    *   **SQL:** Relacional (con tablas y filas).\n    *   **NoSQL:** No-relacional (con documentos, clave-valor, gráficos, columnas).\n\n2.  **Estructura de los datos:**\n    *   **SQL:** Usa tablas con columnas de tipos definidos. Los datos son estrictamente estructurados.\n    *   **NoSQL:** Almacena datos en documentos (JSON, BSON) u otros formatos, permitiendo estructuras más flexibles y anidadas.\n\n3.  **Esquema (Schema):**\n    *   **SQL:** Tiene un esquema estricto y predefinido que debe seguirse. Modificaciones pueden requerir migraciones.\n    *   **NoSQL:** Tiene un esquema flexible o dinámico. Las tablas pueden contener documentos con diferentes campos sin necesidad de modificar el esquema primero.\n\n4.  **Consistencia, Disponibilidad y Partición (CAP):**\n    *   **SQL:** Generalmente ofrece mayor consistencia y cumple mejor con las restricciones de integridad referencial.\n    *   **NoSQL:** Prioriza a menudo la disponibilidad y el rendimiento, permitiendo más flexibilidad en la coherencia (eventual consistency).\n\n5.  **Escalabilidad:**\n    *   **SQL:** Escalabilidad vertical (aumentar el rendimiento de un servidor). A veces compleja la horizontal (distribuir datos).\n    *   **NoSQL:** Escalabilidad horizontal (añadir más servidores) es más común y natural para grandes volúmenes de datos y tráfico.\n\n6.  **Uso típico:**\n    *   **SQL:** Aplicaciones que requieren transacciones complejas, integridad de datos estricta (banco, comercio electrónico, sistemas de gestión).\n    *   **NoSQL:** Aplicaciones con datos grandes y poco estructurados, alta velocidad de escritura, necesidad de escalar horizontalmente fácilmente (big data, aplicaciones web en tiempo real, IoT).\n\n**En resumen:** SQL es más adecuado para datos estructurados y transacciones complejas, mientras que NoSQL ofrece mayor flexibilidad, escalabilidad horizontal y manejo de datos no estructurados.", "confidence": 0.85, "category": "bases_datos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:24:32.326119", "question": "¿Qué es el patrón de diseño Singleton?", "answer": "El **patrón Singleton** es un patrón de diseño creacional que garantiza que una clase tenga **solo una instancia**, y proporciona un punto de acceso global para crear esa instancia.\n\n**En esencia:**\n\n1.  **Clase con constructor privado:** Impide que otras clases puedan crear instancias de manera directa.\n2.  **Método estático de creación:** La clase *ella misma* es la responsable de crear su única instancia (si aún no existe) y devolverla.\n3.  **Control exclusivo:** Cualquier solicitud a crear una instancia resultará en la misma instancia única.\n\n**Se utiliza para:**\n\n*   **Controlar el acceso a recursos:** Asegurar que solo haya una instancia gestiona recursos como configuraciones globales, conexiones a bases de datos o puntos de entrada únicos.\n*   **Evitar recursos redundantes:** Garantizar que no se creen múltiples instancias que manejen la misma funcionalidad o recurso.", "confidence": 0.85, "category": "patrones", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:25:20.441158", "question": "¿Qué es el manejo de excepciones en Python con try/except?", "answer": "**Manejo de excepciones en Python con try/except**\n\nEs una técnica para **capturar y tratar errores** (excepciones) que ocurren durante la ejecución de un programa. \n\n- **try**: Agrupa el código que **podría generar una excepción**.\n- **except**: Define el **comportamiento al detectar una excepción específica**, evitando que el programa termine abruptamente.\n\n**Ejemplo básico:**\n```python\ntry:\n    resultado = 10 / 0\nexcept ZeroDivisionError:\n    print(\"¡Error! No se puede dividir por cero.\")\n```\n\n**Características:**\n- Evita el *crash* del programa.\n- Permite **manejar errores específicos** (ej: `ValueError`, `TypeError`).\n- Se puede anidar múltiples `except` para diferentes excepciones.\n- Se recomienda usar `else` (para código que no lanza excepciones) y `finally` (para operaciones siempre necesarias).", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:25:45.492280", "question": "¿Cómo funciona la herencia en Python?", "answer": "La herencia en Python permite que una **clase derivada (hija)** herede atributos y métodos de una **clase base (superclase)**. Esto facilita la reutilización de código y la creación de jerarquías de clases.\n\n### Funcionamiento básico:\n1. **Clase base**: Define características genéricas.\n   ```python\n   class Animal:\n       def __init__(self, nombre):\n           self.nombre = nombre\n\n       def hablar(self):\n           return f\"{self.nombre} hace un sonido.\"\n   ```\n\n2. **Clase derivada**: Extiende la clase base, añadiendo o modificando funcionalidades.\n   ```python\n   class Perro(Animal):", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:25:57.844263", "question": "¿Qué son los métodos mágicos o dunder methods en Python?", "answer": "**Métodos mágicos o dunder methods en Python**  \nSon funciones integradas en Python que comienzan y terminan con dos underscores (por ejemplo, `__init__`, `__str__`, `__add__`). Estos métodos son reconocidos por el intérprete para sobrecargar operaciones y controlar el comportamiento de los objetos en escenarios específicos, como la inicialización, la representación de datos o la realización de operaciones entre instancias.  \n\n**Ejemplos comunes:**  \n- `__init__(self,...)`: Constructor que inicializa el objeto.  \n- `__str__(self)`: Define cómo se muestra el objeto al usar `print()`.  \n- `__add__(self,other)`: Sobrecarga el operador `+` para clases personalizadas.  \n\nEstos métodos permiten modificar cómo los objetos interactúan con operadores, funciones integradas y el flujo estándar de Python.", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:26:13.290499", "question": "¿Cómo crear y usar una clase en Python?", "answer": "**Cómo crear y usar una clase en Python:**\n\n1. **Definir la clase:**  \n   Usa la palabra clave `class` seguida del nombre (siguiendo la convención `PascalCase`).  \n   ```python\n   class Coche:\n       pass\n   ```\n\n2. **Método `__init__`:**  \n   Es el constructor. Inicializa atributos usando `self`.  \n   ```python\n   class Coche:\n       def __init__(self, marca, modelo):\n           self.marca = marca\n           self.modelo = modelo\n   ```\n\n3. **Métodos y atributos:**  \n   Agrega métodos (funciones dentro de la clase) y atributos (variables ligadas a la instancia).  \n   ```python\n   class Coche:\n       def __init__(self, marca, modelo):\n           self.marca = marca\n           self.modelo = modelo\n\n       def conducir(self):\n           print(f\"Conduciendo el {self.modelo} de {self.marca}\")\n   ```\n\n4. **Crear instancias (objetos):**  \n   Llama a la clase como función y accede a atributos/métodos con `.`.  \n   ```python\n   mi_coche = Coche(\"Toyota\", \"Corolla\")\n   mi_coche.conducir()  # Salida: \"Conduciendo el Corolla de Toyota\"\n   ```\n\n5. **Herencia (opcional):**  \n   Define una clase hija que herede de una clase padre usando `(ClasePadre)`.  \n   ```python\n   class CocheDeportivo(Coche):\n       def __init__(self, marca, modelo, potencia):\n           super().__init__(marca, modelo)\n           self.potencia = potencia\n   ```\n\n**Ejemplo completo:**  \n```python\nclass Animal:\n    def __init__(self, nombre):\n        self.nombre = nombre\n\n    def hablar(self):\n        print(f\"{self.nombre} hace un sonido\")\n\nclass Perro(Animal):\n    def hablar(self):\n        print(f\"{self.nombre} ladra: ¡Guau!\")\n\nperro = Perro(\"Fido\")\nperro.hablar()  # Salida: \"Fido ladra: ¡Guau!\"\n```", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:26:36.806023", "question": "¿Qué es pip y cómo se usa para instalar paquetes?", "answer": "¡Claro!\n\n**Qué es PIP:**\n\nPIP es un **gestor de paquetes** para el lenguaje de programación Python. Su propósito principal es ayudarte a **instalar, eliminar y administrar bibliotecas externas** (paquetes) y sus dependencias.\n\n**¿Cómo se usa para instalar paquetes?**\n\nLa forma más común de instalar un paquete es usando el **comando `pip install`** seguido del nombre del paquete que deseas instalar.\n\n*   **Sintaxis básica:**\n    ```\n    pip install nombre-del-paquete\n    ```\n\n*   **Ejemplos:**\n    *   Para instalar la biblioteca `requests`", "confidence": 1.0, "category": "python", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:26:59.534504", "question": "¿Qué es TypeScript y cuáles son sus ventajas sobre JavaScript?", "answer": "**TypeScript** es un lenguaje de programación de programación que se basa en JavaScript. Es un *sobresete* de JavaScript, lo que significa que todo lo que puedes hacer en JavaScript también puedes hacerlo en TypeScript, pero añade características adicionales.\n\n## Las principales ventajas de TypeScript sobre JavaScript son:\n\n1.  **Tipado Estático:** TypeScript permite definir el tipo de los datos (variables, funciones, objetos, etc.) de manera explícita. Esto ayuda a:\n    *   **Detectar errores temprano:** Muchos errores de lógica o de uso incorrecto de variables pueden detectarse durante la compilación, no esperando a que el programa se ejecute.\n    *   **Mayor claridad y documentación:** El código es más legible y auto-explicativo, especialmente en proyectos grandes.\n    *   **Mejor refactorización:** Es más fácil modificar el código existente de manera segura.\n\n2.  **Características opcionales:** TypeScript incluye características avanzadas de otros lenguajes (como clases, módulos, tipos genéricos, etc.) que están presentes en estándares modernos de JavaScript (ES6+,), pero que son opcionales. Esto significa que puedes usarlas si las necesitas, y el compilador de TypeScript puede generar código para versiones antiguas de JavaScript si es necesario.\n\n3.  **Mejor soporte de herramientas/IDE:** La información de tipos proporcionada a TypeScript permite a los editores de texto e IDEs ofrecer una mejor experiencia:\n    *   Autocompletado inteligente.\n    *   Navegación por código.\n    *   Búsqueda de definiciones.\n    *   Completado de funciones.\n\n4.  **Escalabilidad:** Gracias al tipado y las mejores prácticas de diseño que promueve, TypeScript es particularmente útil para proyectos muy grandes o con muchos desarrolladores, facilitando el mantenimiento y la colaboración.", "confidence": 0.85, "category": "typescript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:27:22.974452", "question": "¿Cómo definir tipos e interfaces en TypeScript?", "answer": "En TypeScript, los **tipos** y las **interfaces** son conceptos clave para definir la estructura de los datos. Aquí su definición y diferencias:\n\n---\n\n### **1. Tipos (Type Aliases)**\nUn **tipo** es una forma de crear nuevos tipos primitivos, genéricos o compuestos. Se define con `type`.\n\n**Sintaxis básica:**\n```typescript\ntype NombreDelTipo = DescripciónDelTipo;\n```\n\n**Ejemplos:**\n```typescript\n// Tipos compuestos\ntype Id = number | string;\ntype Usuario = {\n  nombre: string;\n  edad?: number; // opcional\n};\n```\n\n- **Ventajas:**  \n  - Permite uniones (`|`), intersectiones (`&`), funciones, etc.\n  - Se pueden redefinir (sobrescribir).\n\n---\n\n### **2. Interfaces**\nUna **interfaz** define la estructura de un objeto. Se define con `interface`.\n\n**Sintaxis básica:**\n```typescript\ninterface NombreDeLaInterfaz {\n  propiedad: tipo;", "confidence": 1.0, "category": "typescript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:27:40.554923", "question": "¿Qué son los genéricos en TypeScript?", "answer": "**Genéricos en TypeScript**  \nSon mecanismos que permiten crear componentes (como funciones, interfaces o clases) que trabajan con tipos **dados por el usuario**, manteniendo la seguridad de tipos.  \n\n**Ejemplo:**  \n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// Uso con string:\nconst resultado = identity<string>(\"Hola\"); // Retorna \"Hola\" como string.\n\n// Uso con number:\nconst valor = identity<number>(42); // Retorna 42 como number.\n```\n\n**Beneficios:**  \n- **Flexibilidad:** Funcionan con cualquier tipo (ej. `string`, `number`, `Array`, etc.).  \n- **Seguridad:** TypeScript verifica los tipos en tiempo de compilación.  \n- **Reutilización:** Evitan duplicar código para distintos tipos.  \n\n**Conceptos clave:**  \n- `<T>`: Sintaxis para definir un parámetro de tipo.  \n- Tipos múltiples: Ej. `<T, U>` para manejar dos tipos distintos.  \n\n**¿Para qué sirven?**  \nAumentan la robustez del código al evitar acoplamiento rígido y permitir operaciones seguras con datos de cualquier tipo.", "confidence": 1.0, "category": "typescript", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:27:51.843437", "question": "¿Qué es un componente en React?", "answer": "Un componente en React es una unidad básica de construcción que permite dividir la interfaz de usuario en partes independientes y reutilizables. Puede ser funcional o de clase y devuelve una descripción de lo que debe aparecer en pantalla (generalmente un elemento JSX). Los componentes facilitan la creación de aplicaciones modulares, permitiendo encapsular lógica y presentación.", "confidence": 0.85, "category": "react", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:28:12.128576", "question": "¿Cuál es la diferencia entre props y state en React?", "answer": "**Diferencia entre props y state en React:**\n\n- **Props (Propiedades):**\n  - Son datos pasados de un componente padre a un componente hijo.\n  - Son **inmutables**: el componente hijo no puede modificarlas.\n  - Se usan para pasar configuraciones, datos externos o valores iniciales.\n\n- **State (Estado):**\n  - Es una variable interna de un componente que puede cambiar.\n  - Es **mutable**: el componente puede actualizarlo.\n  - Se utiliza para almacenar datos que pueden modificar el comportamiento o la renderización del componente.\n\n**Ejemplo:**\n```jsx\n// Padre\nconst Button = ({ initialCount }) => {\n  const [count, setCount] = useState(initialCount); // initialCount es una prop\n  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;\n};\n\n// Uso: <Button initialCount={5} />\n```\n\n**En resumen:**  \n- **Props**: Datos externos e inmutables (entrada).  \n- **State**: Datos internos y mutables (salida).", "confidence": 1.0, "category": "react", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:28:39.160443", "question": "¿Qué son los hooks en React y para qué sirven?", "answer": "**¿Qué son los hooks en React y para qué sirven?**\n\n**Los hooks** son funciones incorporadas en React (introducidas en React v16.8) que permiten utilizar **características de React** (como el estado, el ciclo de vida o el contexto) **en componentes funcionales**, eliminando la necesidad de usar clases.\n\n---\n\n### **¿Para qué sirven?**\n1. **Acceso a estados y efectos** sin clases:  \n   - **`useState`**: Para gestionar el estado en componentes funcionales.  \n   - **`useEffect`**: Para manejar efectos secundarios (carga de datos, eventos, intervalos).  \n\n2. **Reutilización de lógica**:  \n   - Puedes compartir código común entre componentes usando **custom hooks** (ej: `useFetch` para reutilizar peticiones HTTP).  \n\n3. **Simplificación del código**:  \n   - Eliminan la sintaxis de clases y el \"this.state\", haciendo el código más limpio y mantenible.  \n\n4. **Mejor comprensión de la lógica**:  \n   - La estructura imperativa de los hooks facilita el seguimiento de dependencias y flujo de datos.  \n\n---\n\n### **Ejemplos comunes**:\n- **`useState`**:  \n  ```jsx\n  const [contador, setContador] = useState(0);\n  ```\n- **`useEffect`**:  \n  ```jsx\n  useEffect(() => {\n    // Ejecutar cuando el componente se monta o actualiza.\n  }, [deps]);\n  ```\n- **`useContext`**:  \n  ```jsx\n  const theme = useContext(ThemeContext);\n  ```\n\n---\n\n### **Reglas clave**:\n- **Solo llamar hooks en componentes funcionales o otros hooks**.  \n- **No modificar el registro interno de React** (React verifica que los hooks se llamen consistentemente en cada renderizado).  \n\n**En resumen**: Los hooks modernizan React al permitir componentes funcionales atractivos, reutilizables y más fáciles de entender.", "confidence": 1.0, "category": "react", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:28:52.831284", "question": "Explica el hook useState en React", "answer": "**Hook `useState` en React**\n\n`useState` es un hook de React que permite a los componentes funcionales gestionar estados mutables de manera declarativa. Funciona así:\n\n1. **Sintaxis básica:**\n   ```jsx\n   import { useState } from 'react';\n\n   function MiComponente() {\n     const [estado, setEstado] = useState(valorInicial);\n     // ... lógica del componente\n     return <div>{estado}</div>;\n   }\n   ```\n\n2. **Componentes:**\n   - **`estado`:** Variable que almacena el valor actual.\n   - **`setEstado`:** Función para actualizar el estado (ejecutada con `setEstado(nuevoValor)`).\n\n3. **Características:**\n   - **Inicialización:** `valorInicial` puede ser un valor primitivo, un objeto, o una función (para casos asíncronos).\n   - **Actualización:** El componente se vuelve a renderizar automáticamente tras cada cambio.\n   - **Control de inputs:** Ideal para manejar valores de formularios.\n\n4. **Ejemplo práctico:**\n   ```jsx\n   const [contador, setContador] = useState(0);\n\n   return (\n     <button onClick={() => setContador(contador + 1)}>\n       Clics: {contador}\n     </button>\n   );\n   ```\n\n**Nota:** Úsalo únicamente para datos que necesiten actualizaciones reactivas en el componente.", "confidence": 1.0, "category": "react", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:29:12.846591", "question": "Explica el hook useEffect en React", "answer": "**Explicación del hook `useEffect` en React**\n\nEl hook `useEffect` permite ejecutar código en el **componente** cuando **se especifican ciertas dependencias** o en momentos clave del ciclo de vida. Es útil para:\n\n- Realizar tareas secundarias (no relacionadas con el renderizado).\n- Ejecutar código cuando el componente **se monta**, **se actualiza** o **se desmonta**.\n- Sustituir `componentDidMount`, `componentDidUpdate` y `componentWillUnmount`.\n\n**Sintaxis básica:**\n```jsx\nuseEffect(() => {\n  // Código a ejecutar\n}, [dependencias]);\n```\n\n**Casos de uso:**\n\n1. **Efectos al montar (se ejecuta solo una vez):**\n   ```jsx\n   useEffect(() => {\n     console.log(\"Componente montado\");\n   }, []); // Array vacío: solo al inicio\n   ```\n\n2. **Efectos al actualizar (cuando dependencias cambian):**\n   ```jsx\n   useEffect(() => {\n     console.log(\"Contador actualizado\", contador);\n   }, [contador]); // Ejecuta solo cuando 'contador' cambia\n   ```\n\n3. **Limpieza (como componentWillUnmount):**\n   ```jsx\n   useEffect(() => {\n     const timer = setInterval(() => {\n       // Actualizar estado periódicamente\n     }, 1000);\n     return () => clearInterval(timer); // Se ejecuta al desmontar o al cambiar dependencias\n   }, []);\n   ```\n\n**Ejemplo completo:**\n```jsx\nimport { useState, useEffect } from 'react';\n\nfunction Contador() {\n  const [contador, setContador] = useState(0);\n\n  useEffect(() => {\n    console.log(\"Contador actualizado:\", contador);\n    // Lógica al actualizar\n  }, [contador]); // Ejecuta solo cuando 'contador' cambia\n\n  return <button onClick={() => setContador(c => c + 1)}>Incrementar</button>;\n}\n```\n\n**Importante:**\n- Las dependencias se pasan como un **array**. Si no hay dependencias, el efecto se ejecuta **una vez** (al montar).\n- **Evitar dependencias infinitas:** No incluir variables mutables en el array de dependencias (ej: `useEffect(() => {...}, [miVariable])` puede causar bucles).", "confidence": 1.0, "category": "react", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:29:39.232194", "question": "¿Qué es una clave primaria y una clave foránea?", "answer": "Claro. Aquí tienes las definiciones:\n\n1.  **Clave Primaria (PK - Primary Key):**\n    *   Es un **atributo o conjunto de atributos** dentro de una **tabla** de una base de datos.\n    *   Su función principal es **identificar de forma única** cada **registro** (fila) de esa tabla.\n    *   Ejemplo: En una tabla de \"Usuarios\", el atributo \"ID\" o \"DNI\" (si es válido y único) podría ser la clave primaria.\n    *   Características clave: Única (no hay dos registros con el mismo valor) y No Nula (ningún registro puede tener este atributo como nulo).\n\n2.  **Clave Foránea (FK - Foreign Key):**\n    *   Es un **atributo o conjunto de atributos** dentro de una **tabla** de una base de datos.\n    *   Su función es **hacer referencia a la clave primaria** de otra tabla (llamada tabla principal o tabla referenciada).\n    *   Ejemplo: En una tabla de \"Pedidos\", el atributo \"ID_Cliente\" sería una clave foránea, ya que se refiere al \"ID\" (clave primaria) de la tabla \"Clientes\".\n    *   Propósito: Establecer **relaciones** entre tablas (como uno a muchos o muchos a muchos) y garantizar la **integridad referencial**, evitando que un registro exista en la tabla secundaria (con la clave foránea) sin corresponder a un registro válido en la tabla principal.", "confidence": 1.0, "category": "bases_datos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:30:10.086403", "question": "¿Qué es el JOIN en SQL y qué tipos existen?", "answer": "**¿Qué es el JOIN en SQL?**\n\nEl **JOIN** es una operación fundamental en SQL utilizada para combinar filas de **dos o más tablas** basándose en un valor común entre ellas (generalmente una columna). Permite acceder a datos relacionados de diferentes tablas en una sola consulta.\n\n**Tipos de JOIN:**\n\n1.  **INNER JOIN (JOIN implícito o explícito):** Devuelve solo las filas donde existe una coincidencia en las columnas especificadas en todas las tablas involucradas. Si no hay coincidencia, esas filas no se incluyen en el resultado. *(Suele ser el más común y se puede hacer con `WHERE` o `USING`, aunque el `INNER JOIN` es más claro).*\n\n2.  **LEFT JOIN (LEFT OUTER JOIN):** Devuelve **todas** las filas de la tabla de la izquierda y las filas coincidentes de la tabla de la derecha. Si no hay coincidencia en la tabla derecha, se incluyen `NULL` en las columnas de esa tabla para las filas de la izquierda.\n\n3.  **RIGHT JOIN (RIGHT OUTER JOIN):** Devuelve **todas** las filas de la tabla de la derecha y las filas coincidentes de la tabla de la izquierda. Si no hay coincidencia en la tabla izquierda, se incluyen `NULL` en las columnas de esa tabla para las filas de la derecha.\n\n4.  **FULL OUTER JOIN (FULL OUTER JOIN):** Devuelve todas las filas cuando hay una coincidencia en *cualquiera* de las tablas involucradas. Las filas que no tienen coincidencia en una tabla se completan con `NULL` en", "confidence": 0.85, "category": "bases_datos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:30:32.123978", "question": "¿Qué es un índice en base de datos y para qué sirve?", "answer": "**Definición:**\n\nUn índice en una base de datos es una estructura de datos que mejora la velocidad de las operaciones de búsqueda y selección de datos en tablas. Es similar a un *índice de libro* que permite encontrar rápidamente un capítulo o página específica en lugar de revisar todo el libro.\n\n**Para qué sirve:**\n\nSu principal función es **optimizar las consultas (SELECT, WHERE, JOIN)** que buscan datos específicos. Al proporcionar una forma rápida de localizar filas en una tabla, los índices permiten que la base de datos no tenga que escanear toda la tabla cada vez que se ejecuta una consulta.\n\n**En resumen:** Los índices mejoran el rendimiento de las *lecturas* de datos, pero pueden ralentizar las *escrituras* (INSERT, UPDATE, DELETE) porque cada índice creado necesita ser actualizado cada vez que cambia el dato.", "confidence": 0.85, "category": "bases_datos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:30:41.520295", "question": "¿Qué es Git y para qué se usa?", "answer": "**Git** es un sistema de control de versiones que permite realizar el seguimiento de los cambios en archivos y coordinar el trabajo de múltiples personas en un mismo proyecto. Se utiliza para:\n\n1. **Gestionar versiones**: Mantener un historial detallado de los cambios realizados en el código.\n2. **Colaboración**: Permitir que varios desarrolladores trabajen en el mismo proyecto sin conflictos.\n3. **Auditoría**: Revisar cambios específicos y revertir a versiones anteriores si es necesario.\n4. **Despliegue**: Integrarse con flujos de trabajo como el GitFlow para gestionar releases.\n\nGit es esencial en el desarrollo de software para asegurar la integridad del código y facilitar el mantenimiento.", "confidence": 0.85, "category": "git", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:31:08.736792", "question": "¿Cuál es la diferencia entre git merge y git rebase?", "answer": "**Diferencia entre `git merge` y `git rebase`:**\n\n1. **`git merge`**:\n   - Crea un **commit de unión (merge commit)** que combina las dos líneas de desarrollo.\n   - Preserva la **historia completa** de ambos ramas, incluyendo los commits originales.\n   - El nuevo commit tiene **dos padres** (el commit de la rama actual y el de la rama que se fusiona).\n   - Es útil para mantener un registro claro de las fusiones en el historial.\n\n2. **`git rebase`**:\n   - **Reescribe la historia** de una rama, aplicando sus commits sobre otra rama (generalmente `main` o `master`).\n   - Cambia los **commit hashes** de los commits rebaseados, lo que puede causar problemas si la rama se comparte.\n   - Hace el historial **más lineal** y limpio.\n   - Útil para mantener una rama actualizada con los cambios de `main` sin fusionar.\n\n**Resumen**:\n- Usa `merge` si quieres **preservar los commits originales** y tener un registro claro de fusiones.\n- Usa `rebase` si quieres **limpiar el historial** y mantener una línea temporal simple, pero evítalo en ramas compartidas.", "confidence": 0.85, "category": "git", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:31:34.157346", "question": "¿Cómo resolver conflictos en Git?", "answer": "Para resolver conflictos en Git, sigue estos pasos:\n\n1. **Identifica el conflicto**: Git marca los archivos con cambios conflictivos y detiene la operación (merge o rebase). Usa `git status` para ver los archivos afectados.\n\n2. **Revisa los cambios**: Abre los archivos conflictivos y busca el marcador `<<<<<<< HEAD` (tus cambios), `=======`, y `>>>>>>>` (versiones de otra rama). Decide cuál mantiene y combina los cambios necesarios.\n\n3. **Marca como resueltos**: Una vez decidido, usa `git add <archivo>` para indicar que el conflicto está resuelto en ese archivo.\n\n4. **Completa la operación**: Ejecuta el comando que inició el conflicto (por ejemplo, `git merge` o `git rebase`) para finalizarlo.\n\n**Ejemplo:**\n```bash\ngit add conflicto/archivo.txt\ngit merge branch-features\n```\n\n**Para prevenir conflictos**:\n- Usa `git pull --rebase` en lugar de `git pull` para mantener el historial limpio.\n- Coordina con tu equipo para evitar modificar el mismo archivo en paralelo.\n\n**Herramientas útiles**:  \n- `git mergetool` (para resoluciones gráficas).  \n- Herramientas visuales como **GitKraken** o **SourceTree**.", "confidence": 1.0, "category": "git", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:31:56.234341", "question": "¿Qué es una estructura de datos tipo pila (stack)?", "answer": "Una **estructura de datos tipo pila (stack)** es un conjunto ordenado de elementos donde las operaciones básicas permiten:\n\n1.  **Push (apilar):** Añadir un elemento al **tope** de la pila.\n2.  **Pop (desapilar):** Eliminar el elemento del **tope** de la pila.\n3.  **Top (mirar el tope):** Acceder al elemento que está en el **toila** de la pila, sin eliminarlo.\n\nSu característica fundamental es el **principio LIFO (Last In, First Out)**, lo que significa que el **último elemento en ser añadido** es el **primero en ser eliminado**. Se comporta como una pila vertical, donde puedes solo añadir o quitar elementos desde la parte superior.", "confidence": 0.85, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:32:13.007371", "question": "¿Qué es una estructura de datos tipo cola (queue)?", "answer": "Una **cola (queue)** es una estructura de datos **lineal** que sigue el principio **FIFO** (First-In-First-Out), lo que significa que el elemento que se inserta primero es el primero en ser eliminado.\n\n**Características principales:**\n\n*   **Cola (Frente):** El extremo desde el cual se extraen los elementos.\n*   **Final:** El extremo desde el cual se insertan los elementos.\n\n**Ejemplo:** Es similar a una fila de personas en un supermercado, donde la primera en llegar es la primera en ser atendida.", "confidence": 1.0, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:32:37.548001", "question": "¿Qué es un árbol binario de búsqueda?", "answer": "Un árbol binario de búsqueda (ABB) es un **tipo especial de árbol binario** donde se cumplen propiedades de ordenamiento. Estas propiedades garantizan que los elementos se encuentren organizados de forma eficiente.\n\n**Propiedades clave:**\n1. **Cada nodo** tiene como máximo dos hijos: **izquierdo** y **derecho**.\n2. **Regla de ordenamiento:**\n   * Todos los nodos en el **subárbol izquierdo** de un nodo tienen valores menores que el nodo.\n   * El nodo **actual** es mayor que todos los nodos de su subárbol izquierdo y menor que todos los nodos de su subárbola derecha.\n   * Todos los nodos en el **subárbol derecho** tienen valores mayores que el nodo.\n\n**En resumen:** Es un árbol binario donde los valores están ordenados de manera que facilita operaciones como **buscar**, **insertar** y **eliminar** en un tiempo promedio eficiente (O(log n) en un árbol balanceado).", "confidence": 0.85, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:33:00.686036", "question": "¿Qué es la recursividad y cuándo usarla?", "answer": "**¿Qué es la recursividad?**  \nLa recursividad es un concepto en el que una función o algoritmo se llama a sí mismo para resolver un subproblema más pequeño, hasta alcanzar un caso base (situación que no requiere recursión). Es común en matemáticas y programación, y se usa para resolver problemas que pueden dividirse en instancias más pequeñas del mismo problema.\n\n**¿Cuándo usarla?**  \nEs útil para:  \n1. **Problemas naturales que se dividen en partes similares** (ej: árboles genealógicos, cálculo de potencias, algoritmos de búsqueda en arboles).  \n2. **Situaciones donde la iteración es compleja** (ej: recorrer estructuras fractales, definir secuencias recursivas).  \n3. **Cuando el caso base es claro y los subproblemas son independientes**.\n\n**Importante:**  \n- Usa recursividad con cuidado, ya que los lenguajes tienen límites en la profundidad de las llamadas recursivas (puede causar *stack overflow*).  \n- Opta por iteración cuando sea posible, ya que es más eficiente en la mayoría de casos.", "confidence": 0.85, "category": "algoritmos", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:33:29.045060", "question": "¿Qué es el patrón Factory en programación?", "answer": "Claro. El **patrón Factory** es un **patrón de diseño creacional**.\n\n**En resumen:**\nEs un método para **ocultar la lógica de creación de objetos** detrás de una interfaz. En lugar de instanciar directamente una clase concreta (como `new ClaseConcreta()`), se utiliza una función o clase (**Factory**) que *devuelve* un objeto de la clase adecuada.\n\n**Conceptos clave:**\n\n1.  **Interfaz de Creación:** Se define una forma estándar de crear un objeto sin especificar su clase concreta.\n2.  **Encapsulación de la Lógica:** La clase Factory encapsula cómo se crean y, a menudo, cómo se configuran los objetos específicos.\n3.  **Abstracción:** Permite trabajar con una abstracción de objeto, no con una implementación concreta.\n\n**Ejemplo común:**\n\n*   **En lugar de:** `Documento *doc = new PDF();`\n*   **Tenemos:** `Documento *doc = DocumentoFactory::crear(\"PDF\");` (La Factory decide crear el objeto PDF).\n\n**Beneficios:**\n\n*   **Flexibilidad:** Fácil de modificar el tipo de objeto creado sin cambiar el código del cliente.\n*   **Mantenibilidad:** El código de creación está separado del código que usa los objetos.\n*   **Ocultación de detalles:** El cliente no necesita conocer la clase concreta del objeto creado.\n\nEs una forma eficaz de **abstraer la creación de objetos**, especialmente cuando se necesita manejar diferentes tipos de objetos basados en ciertas condiciones o configuraciones.", "confidence": 1.0, "category": "patrones", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:33:47.805710", "question": "¿Qué es el patrón Observer?", "answer": "El patrón Observer es un patrón de diseño de software que permite establecer una relación uno-a-many (uno-sujeto, muchos-observadores). Cuando el sujeto cambia su estado, todos los observadores asociados son notificados automáticamente para que puedan actualizarse.\n\n**Características clave:**\n- **Desacoplamiento:** El sujeto no necesita conocer los observadores, y viceversa.\n- **Flexibilidad:** Fácil de agregar nuevos observadores sin modificar el código del sujeto.\n- **Actualización centralizada:** El sujeto maneja la notificación, evitando múltiples llamadas directas.\n\n**Ejemplo común:** Un panel de control en una aplicación que muestra datos en tiempo real (como un reloj digital y un gráfico) al cambiar el estado del sistema.", "confidence": 1.0, "category": "patrones", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:34:17.157089", "question": "¿Qué es el patrón MVC (Model-View-Controller)?", "answer": "Claro, aquí tienes una respuesta clara y concisa:\n\n**El patrón MVC (Model-View-Controller)** es un paradigma de diseño de software que divide una aplicación en tres componentes principales:\n\n1.  **Modelo (Model):** Gestiona los datos, la lógica y las reglas de negocio de la aplicación. Representa el estado de la aplicación.\n2.  **Vista (View):** Es responsable de mostrar al usuario la presentación de los datos (Model) y recibir las entradas del usuario (por ejemplo, clics en botones). Solo debe mostrar y recibir datos, sin contener lógica de negocio.\n3.  **Controlador (Controller):** Intermedia entre el Modelo y la Vista. Captura las entradas del usuario (desde la Vista), las interpreta y decide si modificar el Modelo o actualizar la Vista, delegando la lógica correspondiente.\n\n**En resumen:** MVC separa la lógica de la aplicación (Model) de su presentación (View) y del flujo de control (Controller), facilitando el desarrollo, la prueba y la mantenibilidad del código.", "confidence": 1.0, "category": "patrones", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:34:47.440945", "question": "¿Qué es una API REST y cuáles son sus principios?", "answer": "Claro, aquí tienes la respuesta:\n\nUna **API REST** (Representación Estatal de Transferencia) es un estilo de diseño de arquitectura de software para sistemas de información, especialmente para aplicaciones que se comunican a través de una red (como la web).\n\nSus principales **principios** son:\n\n1.  **Identificabilidad:** Cada recurso (por ejemplo, un usuario, un producto) debe tener una identidad única y una URL correspondiente.\n2.  **Interfaz Uniforme:** Debe existir una manera predecible y consistente de interactuar con los recursos, usando principalmente métodos HTTP estándar (GET, POST, PUT, DELETE) y formatos de datos estándar (como JSON o XML).\n3.  **Sin Estado (Statelessness):** Cada solicitud debe contener toda la información necesaria para que el servidor entienda y procese la solicitud. El servidor no debe guardar información sobre la sesión del cliente en una llamada anterior (excepto en el almacenamiento local del navegador del cliente).\n4.  **Séparación del Cliente y el Servidor:** La forma en que funciona el servidor no debe depender de la tecnología o interfaz utilizada por el cliente.\n5.  **Sistema de Capas:** El cliente y el servidor no necesitan saber si existen intermediarios entre ellos (como servidores", "confidence": 1.0, "category": "web", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:35:16.717187", "question": "¿Qué son los métodos HTTP GET, POST, PUT y DELETE?", "answer": "Claro. Aquí están los significados básicos de los métodos HTTP GET, POST, PUT y DELETE:\n\n1.  **GET:** Se utiliza para **obtener** o **leer** datos de un servidor. Es una operación **idempotente y segura** (no debería cambiar el estado del servidor y múltiples peticiones producirían el mismo resultado).\n    *   *Ejemplo:* Pedir los detalles de un usuario específico o cargar una página web.\n\n2.  **POST:** Se utiliza para **enviar datos** al servidor para **crear** un nuevo recurso o **enviar** datos que pueden modificar el servidor (en el contexto de operaciones que no son \"crear\", ver PUT/PATCH). Es **no idempotente** (cada petición puede tener un efecto diferente). Los datos se incluyen en el cuerpo de la solicitud.\n    *   *Ejemplo:* Registrar un nuevo usuario o enviar un mensaje en un formulario.\n\n3.  **PUT:** Se utiliza para **enviar datos** al servidor para **reemplazar** (actualizar) un recurso existente en su totalidad. Es una operación **idempotente", "confidence": 1.0, "category": "web", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:35:34.287919", "question": "¿Qué es JSON y para qué se usa?", "answer": "¡Claro! Aquí tienes una respuesta clara y concisa:\n\n**JSON** (JavaScript Object Notation) es un formato ligero para el intercambio y almacenamiento de datos. Es fácil de leer y escribir, tanto para humanos como para máquinas.\n\n**Se utiliza principalmente:**\n*   Para transmitir datos entre un servidor y un cliente (a través de APIs).\n*   Para configurar aplicaciones.\n*   Para almacenar datos en aplicaciones web.\n*   Cualquier lugar donde se necesite compartir datos de manera sencilla y eficiente entre sistemas.", "confidence": 0.85, "category": "web", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:36:03.522169", "question": "¿Qué es la programación orientada a objetos?", "answer": "**Programación Orientada a Objetos (POO)** es un paradigma de programación que organiza el código alrededor de **objetos** (instancias de **clases**), que representan entidades del mundo real.\n\nLos conceptos clave son:\n\n1.  **Objetos:** Piezas concretas del programa. Tienen:\n    *   **Atributos:** Características o datos propios del objeto (variables).\n    *   **Métodos:** Funciones o acciones que el objeto puede realizar (procedimientos).\n\n2.  **Clases:** Plantillas o moldes que definen la estructura y el comportamiento general de los objetos. Una clase define qué atributos y métodos tendrán sus objetos.\n\n3.  **Encapsulamiento:** Agrupar datos (atributos) y los métodos que actúan sobre ellos en una unidad (la clase), ocultando su implementación interna y controlando el acceso a sus atributos. Se protege la integridad de los datos.\n\n4.  **Abstracción:** Ocultar la complejidad interna de los objetos, mostrando solo las características esenciales necesarias para interactuar con ellos. Se logra mediante interfaces y métodos definidos en las clases.\n\n5.  **Herencia:** Permite que una clase (hija o subclase) herede propiedades (atributos) y comportamientos (métodos) de otra clase (padre o superclase). Facilita la reutilización de código.\n\n6.  **Polimorfismo:** Permite tratar objetos de diferentes clases de manera uniforme (como si fueran del mismo tipo base). Un mismo método puede comportarse de manera diferente dependiendo del objeto al que se le aplique.\n\n**En resumen:** La POO busca modelar el problema real utilizando objetos, lo que hace el código más intuitivo, modular, fácil de mantener y extender. Por ejemplo, en lugar", "confidence": 1.0, "category": "general", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:36:21.371274", "question": "¿Qué es la programación funcional?", "answer": "La programación funcional es un paradigma de programación donde:\n\n1.  **Las funciones son valores**: Pueden tratarse como entidades pasadas por parámetros o retornadas.\n2.  **Evita el estado mutable e instrucciones laterales**: Los datos no cambian (inmutabilidad) y las funciones solo dependen de sus entradas.\n3.  **Se basa en composición**: Se construyen programas combinando funciones simples.\n\nEn resumen, es un enfoque que prioriza las funciones y el tratamiento de datos inmutables para desarrollar programas.", "confidence": 0.85, "category": "general", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:36:42.507797", "question": "¿Cuál es la diferencia entre compilación e interpretación?", "answer": "**Diferencia entre compilación e interpretación:**\n\n1. **Compilación:**\n   - El **compilador** traduce todo el código fuente a un programa ejecutable independiente en un solo paso, antes de que se ejecute.\n   - El archivo ejecutable resultante se puede correr sin necesidad de volver a traducirlo.\n   - La detección de errores ocurre durante la compilación. El ejecutable final no puede depurar errores a menos que se recompile.\n   - Ejemplo: Lenguajes como C++, Java.\n\n2. **Interpretación:**\n   - El **intérprete** traduce y ejecuta el código línea por línea en tiempo real.\n   - No se crea un archivo ejecutable independiente; se necesita el intérprete y el código fuente originales para correrlo.\n   - Los errores se detectan durante la ejecución.\n   - Ejemplo: Lenguajes como Python, JavaScript.\n\nEn resumen:\n- **Compilación:** Todo el código primero, luego se ejecuta. Velocidad generalmente mayor.\n- **Interpretación:** Línea por línea durante la ejecución. Detección de errores en tiempo de runtime.", "confidence": 1.0, "category": "general", "model": "deepseek-r1:8b", "quality_validated": true}
{"timestamp": "2025-11-27T21:36:55.638170", "question": "¿Qué es el testing en desarrollo de software?", "answer": "Claro, aquí tienes la respuesta:\n\nEl **testing en desarrollo de software** es el proceso de analizar un software (o una parte de él) con el objetivo de encontrar defectos (bugs, errores), así como verificar que cumple con los requisitos y la funcionalidad especificada.\n\nEn resumen, es la validación del software para asegurar su calidad y funcionamiento correcto antes de su lanzamiento.", "confidence": 0.85, "category": "general", "model": "deepseek-r1:8b", "quality_validated": true}
