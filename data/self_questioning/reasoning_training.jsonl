{"timestamp": "2025-11-28T17:21:10.360946", "question": "Si tengo 3 manzanas y me dan el doble, luego regalo 2, cuantas me quedan?", "answer": "Vamos a resolver esto paso a paso:\n\n1. Empiezo con 3 manzanas\n2. Me dan el doble: 3 x 2 = 6 manzanas\n3. Ahora tengo: 3 + 6 = 9 manzanas\n4. Regalo 2: 9 - 2 = 7 manzanas\n\nRespuesta: Me quedan 7 manzanas.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Un tren sale a las 9:00 y tarda 2 horas y 45 minutos. A que hora llega?", "answer": "Resolvamos paso a paso:\n\n1. Hora de salida: 9:00\n2. Duracion del viaje: 2 horas y 45 minutos\n3. Sumamos las horas: 9:00 + 2:00 = 11:00\n4. Sumamos los minutos: 11:00 + 0:45 = 11:45\n\nRespuesta: El tren llega a las 11:45.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Si un libro cuesta 25 euros y tiene 30% de descuento, cuanto pago?", "answer": "Calculemos el descuento:\n\n1. Precio original: 25 euros\n2. Descuento: 30%\n3. Valor del descuento: 25 x 0.30 = 7.5 euros\n4. Precio final: 25 - 7.5 = 17.5 euros\n\nRespuesta: Pagas 17.50 euros.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Tengo 5 camisas y 3 pantalones. Cuantas combinaciones diferentes puedo hacer?", "answer": "Apliquemos el principio de multiplicacion:\n\n1. Opciones de camisas: 5\n2. Opciones de pantalones: 3\n3. Cada camisa puede combinarse con cada pantalon\n4. Total de combinaciones: 5 x 3 = 15\n\nRespuesta: Puedes hacer 15 combinaciones diferentes.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Si Ana es mas alta que Bea, y Bea es mas alta que Clara, quien es la mas baja?", "answer": "Analicemos las relaciones:\n\n1. Ana > Bea (Ana es mas alta que Bea)\n2. Bea > Clara (Bea es mas alta que Clara)\n3. Por transitividad: Ana > Bea > Clara\n4. El orden de altura es: Ana (mas alta), Bea (media), Clara (mas baja)\n\nRespuesta: Clara es la mas baja.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Como ordenarias una lista de numeros [5, 2, 8, 1, 9] de menor a mayor?", "answer": "Usemos el algoritmo de ordenamiento burbuja explicado paso a paso:\n\nLista inicial: [5, 2, 8, 1, 9]\n\nPrimera pasada:\n- Comparo 5 y 2: intercambio -> [2, 5, 8, 1, 9]\n- Comparo 5 y 8: no intercambio -> [2, 5, 8, 1, 9]\n- Comparo 8 y 1: intercambio -> [2, 5, 1, 8, 9]\n- Comparo 8 y 9: no intercambio -> [2, 5, 1, 8, 9]\n\nSegunda pasada:\n- [2, 5, 1, 8, 9] -> [2, 1, 5, 8, 9]\n\nTercera pasada:\n- [2, 1, 5, 8, 9] -> [1, 2, 5, 8, 9]\n\nResultado final: [1, 2, 5, 8, 9]", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Que hace este codigo: for i in range(5): print(i*2)?", "answer": "Analicemos el codigo linea por linea:\n\n1. `for i in range(5)`: Crea un bucle que itera con i = 0, 1, 2, 3, 4\n2. `print(i*2)`: Imprime el valor de i multiplicado por 2\n\nEjecucion paso a paso:\n- i = 0: imprime 0 * 2 = 0\n- i = 1: imprime 1 * 2 = 2\n- i = 2: imprime 2 * 2 = 4\n- i = 3: imprime 3 * 2 = 6\n- i = 4: imprime 4 * 2 = 8\n\nSalida: 0, 2, 4, 6, 8 (cada uno en una linea)", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Como encontrarias el numero mas grande en una lista?", "answer": "Algoritmo para encontrar el maximo:\n\n1. Supongo que el primer elemento es el maximo\n2. Recorro la lista comparando cada elemento\n3. Si encuentro uno mayor, actualizo el maximo\n4. Al terminar, tengo el maximo\n\nEjemplo con [3, 7, 2, 9, 4]:\n- max_actual = 3\n- Comparo 7 > 3? Si, max_actual = 7\n- Comparo 2 > 7? No\n- Comparo 9 > 7? Si, max_actual = 9\n- Comparo 4 > 9? No\n\nResultado: El maximo es 9", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Deberia usar una base de datos SQL o NoSQL para mi aplicacion de redes sociales?", "answer": "Analicemos ambas opciones:\n\n**Requisitos de redes sociales:**\n- Muchos usuarios\n- Posts, comentarios, likes\n- Relaciones entre usuarios (amigos/seguidores)\n- Consultas frecuentes y variadas\n- Escalabilidad\n\n**SQL (Relacional):**\n+ Bueno para relaciones complejas (amigos, grupos)\n+ Transacciones ACID\n+ Consultas estructuradas\n- Escalabilidad horizontal mas compleja\n\n**NoSQL (Documento/Grafo):**\n+ Escalabilidad horizontal facil\n+ Esquema flexible\n+ Alto rendimiento para lecturas\n- Consultas complejas mas dificiles\n\n**Recomendacion:** Una arquitectura hibrida:\n- PostgreSQL para usuarios y relaciones criticas\n- MongoDB/Redis para posts y cache\n\nEsto combina lo mejor de ambos mundos.", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Como debuggearias un programa que se cuelga aleatoriamente?", "answer": "Metodologia de debugging sistematica:\n\n**Paso 1: Recopilar informacion**\n- Cuando ocurre el problema?\n- Hay patrones? (hora, carga, acciones especificas)\n- Revisar logs de errores\n\n**Paso 2: Reproducir el problema**\n- Intentar aislar las condiciones\n- Crear un caso de prueba minimo\n\n**Paso 3: Investigar causas comunes**\n- Memory leaks (uso creciente de memoria)\n- Race conditions (problemas de concurrencia)\n- Deadlocks (bloqueos mutuos)\n- Recursos agotados (archivos, conexiones)\n\n**Paso 4: Herramientas de diagnostico**\n- Profilers de memoria\n- Logs detallados\n- Core dumps\n- Monitoreo de recursos\n\n**Paso 5: Aislar y corregir**\n- Dividir el codigo en secciones\n- Probar cada parte\n- Aplicar fix y validar", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360946", "question": "Diseña una API REST para una tienda online", "answer": "Diseñemos la API paso a paso:\n\n**1. Identificar recursos principales:**\n- Productos\n- Usuarios\n- Carritos\n- Pedidos\n\n**2. Definir endpoints:**\n\nProductos:\n- GET /products - Listar productos\n- GET /products/{id} - Detalle de producto\n- POST /products - Crear (admin)\n- PUT /products/{id} - Actualizar (admin)\n- DELETE /products/{id} - Eliminar (admin)\n\nUsuarios:\n- POST /users/register - Registro\n- POST /users/login - Login\n- GET /users/me - Perfil actual\n\nCarrito:\n- GET /cart - Ver carrito\n- POST /cart/items - Añadir item\n- DELETE /cart/items/{id} - Quitar item\n\nPedidos:\n- POST /orders - Crear pedido desde carrito\n- GET /orders - Historial\n- GET /orders/{id} - Detalle\n\n**3. Consideraciones:**\n- Autenticacion con JWT\n- Paginacion para listas\n- Codigos HTTP apropiados\n- Validacion de datos", "confidence": 0.95, "cognitive_age": 14, "category": "chain_of_thought", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Explica como funciona la recursion con un ejemplo", "answer": "Claro. La recursión es una técnica donde una función se llama a sí misma para resolver un problema, dividiéndolo en versiones más pequeñas de sí mismo.\n\nToda función recursiva tiene dos partes clave:\n1.  **Caso Base:** Una condición que detiene las llamadas para evitar un bucle infinito.\n2.  **Paso Recursivo:** La parte donde la función se invoca a sí misma con un argumento modificado, acercándose al caso base.\n\n**Ejemplo: Factorial de 4 (4!)**\n\nLa función `factorial(n)` calcula `n * factorial(n-1)`. El caso base es `factorial(1)`, que devuelve `1`.\n\nEl proceso de llamadas es el siguiente:\n1.  Se llama a `factorial(4)`. Para resolverse, debe esperar el resultado de `4 * factorial(3)`.\n2.  Se llama a `factorial(3)`. Espera por `3 * factorial(2)`.\n3.  Se llama a `factorial(2)`. Espera por `2 * factorial(1)`.\n4.  Se llama a `factorial(1)`. Este es el **caso base**, y devuelve `1` inmediatamente.\n\nAhora, las llamadas pendientes se resuelven en orden inverso:\n- `factorial(2)` recibe `1` y devuelve `2 * 1 = 2`.\n- `factorial(3)` recibe `2` y devuelve `3 * 2 = 6`.\n- `factorial(4)` recibe `6` y devuelve `4 * 6 = 24`.\n\nEl resultado final es 24.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Cual es la diferencia entre concurrencia y paralelismo?", "answer": "Claro. Aquí tienes la explicación:\n\nLa concurrencia y el paralelismo no son lo mismo, aunque están relacionados.\n\n**Concurrencia** es la capacidad de gestionar múltiples tareas a la vez, pero no necesariamente ejecutarlas al mismo tiempo. Imagina un chef en una cocina (un solo núcleo de CPU). Puede empezar a cortar verduras, luego poner a hervir agua y después revisar el horno. Aunque gestiona varias tareas, solo hace una a la vez, cambiando rápidamente entre ellas. Un servidor web que atiende a múltiples usuarios es un ejemplo: maneja muchas conexiones de forma concurrente.\n\n**Paralelismo** es la ejecución simultánea de múltiples tareas. Requiere hardware con varios núcleos o procesadores. Imagina un equipo de chefs. Mientras uno corta verduras, otro cocina la salsa y un tercero decora el postre, todo al mismo tiempo. Un ejemplo práctico es el renderizado de video, donde diferentes núcleos de la CPU procesan distintas partes del video simultáneamente para acelerar el trabajo.\n\nEn resumen: la concurrencia es estructural (manejar muchas cosas a la vez), mientras que el paralelismo es ejecución real y simultánea (hacer muchas cosas a la vez).", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Que es el patron de diseño Singleton y cuando usarlo?", "answer": "El patrón Singleton garantiza que una clase tenga una única instancia y proporciona un punto de acceso global a ella. Resuelve el problema de necesitar un solo objeto para coordinar acciones en todo el sistema, como un gestor de configuración, un logger o una conexión a base de datos.\n\nSe implementa creando una clase con un constructor privado, lo que impide la instanciación directa. La clase contiene un método estático (comúnmente llamado `getInstance()`) que crea la instancia la primera vez que se le llama y la almacena. En llamadas posteriores, simplemente devuelve la instancia ya existente.\n\n**Ventajas:**\n*   Asegura el acceso controlado a la única instancia.\n*   Ahorra memoria al prevenir la creación de objetos duplicados.\n\n**Desventajas:**\n*   Puede ocultar dependencias y crear un estado global, dificultando las pruebas unitarias.\n*   Viola el Principio de Responsabilidad Única, ya que la clase maneja tanto su lógica de negocio como su ciclo de vida.\n\nEs apropiado usarlo con moderación, principalmente para gestionar recursos que son inherentemente únicos y compartidos en una aplicación.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Como optimizarias una consulta SQL lenta?", "answer": "Claro. Aquí tienes un proceso para optimizar una consulta SQL lenta:\n\n1.  **Diagnóstico con `EXPLAIN`**: Ejecuta `EXPLAIN` (o `EXPLAIN ANALYZE`) antes de tu consulta. Analiza el resultado para identificar cuellos de botella, como \"Full Table Scans\" (escaneos completos de tabla), que indican que la consulta no está usando índices eficientemente.\n\n2.  **Creación de Índices**: Si el plan de ejecución muestra escaneos completos en columnas usadas en cláusulas `WHERE`, `JOIN` u `ORDER BY`, crea índices en ellas. Esto acelera la búsqueda de datos de manera similar al índice de un libro.\n    ```sql\n    CREATE INDEX nombre_indice ON tu_tabla (columna);\n    ```\n\n3.  **Optimización de la Consulta**:\n    *   Selecciona solo las columnas que necesitas en lugar de usar `SELECT *`.\n    *   Evita funciones en las columnas dentro del `WHERE` (ej. `WHERE YEAR(fecha) = 2024`), ya que pueden anular el uso de índices. En su lugar, usa rangos (ej. `WHERE fecha >= '2024-01-01' AND fecha < '2025-01-01'`).\n    *   Asegúrate de que los `JOIN` se realicen sobre columnas indexadas.\n\n4.  **Verificación**: Vuelve a ejecutar `EXPLAIN` para confirmar que el nuevo plan de ejecución utiliza los índices y es más eficiente.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Cual es la complejidad temporal de buscar en una lista vs un diccionario?", "answer": "Claro.\n\nBuscar en una **lista (array)** tiene una complejidad temporal de **O(n)**, o tiempo lineal. Esto se debe a que, en el peor caso, el algoritmo debe recorrer cada elemento uno por uno, desde el principio hasta el final, para encontrar el valor buscado. El tiempo de búsqueda aumenta proporcionalmente con el número de elementos (`n`) en la lista.\n\nPor otro lado, buscar en un **diccionario (hash table)** tiene una complejidad temporal promedio de **O(1)**, o tiempo constante. Esta eficiencia se logra gracias a una \"función hash\", que convierte la clave de búsqueda en un índice numérico de forma casi instantánea. Este índice apunta directamente a la ubicación del valor en memoria, eliminando la necesidad de recorrer otros elementos.\n\nLa diferencia clave es que la lista requiere una inspección secuencial, mientras que el diccionario permite un acceso directo, haciendo que su velocidad de búsqueda sea independiente del tamaño de la colección.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Como diseñarias un sistema de cache?", "answer": "Para diseñar un sistema de caché efectivo, primero identifica datos de acceso frecuente que son costosos de generar o recuperar (ej. resultados de queries a base de datos, llamadas a APIs). El objetivo es almacenar estos datos en una memoria más rápida, como RAM, para acelerar futuras solicitudes.\n\n**Estrategias de Invalidación:**\n*   **LRU (Least Recently Used):** Cuando la caché está llena, elimina el elemento menos usado recientemente. Es ideal para datos con patrones de acceso donde lo reciente es relevante.\n*   **TTL (Time-To-Live):** A cada elemento se le asigna un tiempo de vida. Al expirar, se elimina. Es perfecto para datos que pierden vigencia, como cotizaciones o estados temporales.\n\n**Consideraciones de Memoria:**\nEl tamaño de la caché es un balance entre rendimiento y costo. Una caché más grande aumenta la probabilidad de aciertos (cache hits), pero consume más memoria. Debes monitorear el uso para evitar agotar los recursos del sistema.\n\nEn resumen, usa la caché para datos leídos con frecuencia y que no cambian constantemente. Elige una estrategia de invalidación (o una combinación) que se alinee con el patrón de acceso y la naturaleza de tus datos para maximizar la eficiencia.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:21:10.360964", "question": "Que es una API RESTful y cuales son sus principios?", "answer": "Claro. REST (Representational State Transfer) es un estilo de arquitectura para diseñar APIs web. Se basa en varios principios clave:\n\n1.  **Stateless (Sin estado):** Cada petición del cliente al servidor debe contener toda la información necesaria para ser procesada. El servidor no guarda ningún contexto sobre el cliente entre peticiones. Esto simplifica el diseño y mejora la escalabilidad.\n\n2.  **Recursos:** Todo es un \"recurso\" (un usuario, un producto, etc.) y se identifica con una URI única. Por ejemplo, `/usuarios/123` identifica al usuario con el ID 123.\n\n3.  **Verbos HTTP:** Se utilizan los métodos estándar de HTTP para manipular los recursos:\n    *   **GET:** Para leer un recurso (`GET /usuarios/123`).\n    *   **POST:** Para crear un nuevo recurso (`POST /usuarios`).\n    *   **PUT:** Para actualizar un recurso existente (`PUT /usuarios/123`).\n    *   **DELETE:** Para eliminar un recurso (`DELETE /usuarios/123`).\n\n4.  **Códigos de Respuesta:** Se usan códigos de estado HTTP estándar para indicar el resultado de una petición, como `200 OK` (éxito), `201 Created` (recurso creado), `404 Not Found` (no encontrado) o `500 Internal Server Error`.", "confidence": 0.9, "cognitive_age": 14, "category": "technical_reasoning", "self_generated": true, "source": "gemini", "reasoning_training": true}
{"timestamp": "2025-11-28T17:26:22.068844", "question": "como debo pensar para resolver problemas complejos?", "answer": "Para resolver problemas complejos, sigo este proceso:\n\n1. **Entender el problema**\n   - Que se me esta pidiendo exactamente?\n   - Cuales son los datos de entrada?\n   - Cual es el resultado esperado?\n\n2. **Descomponer en partes**\n   - Dividir el problema en subproblemas mas pequeños\n   - Identificar las dependencias entre partes\n\n3. **Resolver paso a paso**\n   - Atacar cada subproblema\n   - Verificar cada paso antes de continuar\n\n4. **Verificar la solucion**\n   - Funciona para el caso dado?\n   - Funciona para casos limite?\n   - Hay una solucion mejor?\n\nEste enfoque sistematico me ayuda a mantener claridad y evitar errores.", "confidence": 0.95, "cognitive_age": 14, "category": "meta_reasoning", "self_generated": true, "reasoning_training": true}
{"timestamp": "2025-11-28T17:26:22.068844", "question": "cuando debo usar chain of thought?", "answer": "Uso razonamiento paso a paso (chain of thought) cuando:\n\n1. **Problemas matematicos** - Calculos que requieren multiples pasos\n2. **Logica y deduccion** - Cuando hay que conectar multiples premisas\n3. **Debugging** - Para rastrear el origen de un error\n4. **Diseño** - Al tomar decisiones arquitectonicas\n5. **Explicaciones** - Cuando necesito enseñar algo\n\nEl razonamiento explicito me ayuda a:\n- No saltar pasos importantes\n- Detectar errores en mi logica\n- Comunicar mejor mi proceso\n- Obtener resultados mas precisos\n\nEn cambio, para preguntas simples o factuales, puedo responder directamente.", "confidence": 0.95, "cognitive_age": 14, "category": "meta_reasoning", "self_generated": true, "reasoning_training": true}
